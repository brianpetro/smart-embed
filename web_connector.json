{
  "script": "var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __commonJS = (cb, mod) => function __require() {\n  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\n\n// SmartEmbed.js\nvar require_SmartEmbed = __commonJS({\n  \"SmartEmbed.js\"(exports) {\n    var SmartEmbed = class {\n      static async create() {\n        const adapter = new this();\n        await adapter.init();\n        return adapter;\n      }\n      async init() {\n      }\n      /**\n       * @param {string} input\n       * @returns {Promise<number>}\n       */\n      async count_tokens(input) {\n      }\n      /**\n       * @param {string} input\n       * @returns {Promise<number[]>}\n       */\n      async embed(input) {\n      }\n      /**\n       * @param {string[]} input\n       * @returns {Promise<number[][]>}\n       */\n      async embed_batch(input) {\n      }\n    };\n    exports.SmartEmbed = SmartEmbed;\n  }\n});\n\n// SmartEmbedTransformersNodeAdapter.js\nvar require_SmartEmbedTransformersNodeAdapter = __commonJS({\n  \"SmartEmbedTransformersNodeAdapter.js\"(exports) {\n    var { SmartEmbed } = require_SmartEmbed();\n    var SmartEmbedTransformersNodeAdapter = class extends SmartEmbed {\n      async init(model_name = \"Xenova/bge-small-en-v1.5\") {\n        const { env, pipeline, AutoTokenizer } = await import(\"@xenova/transformers\");\n        env.allowLocalModels = false;\n        this.model = await pipeline(\"feature-extraction\", model_name, { quantized: true });\n        this.tokenizer = await AutoTokenizer.from_pretrained(model_name);\n      }\n      async embed_batch(items) {\n        const tokens = await Promise.all(items.map((item) => this.count_tokens(item.embed_input)));\n        const embed_input = items.map((item, i) => {\n          if (tokens[i] < 512)\n            return item.embed_input;\n          const pct = 512 / tokens[i];\n          const max_chars = Math.floor(item.embed_input.length * pct * 0.95);\n          return item.embed_input.substring(0, max_chars) + \"...\";\n        });\n        try {\n          const resp = await this.model(embed_input, { pooling: \"mean\", normalize: true });\n          return items.map((item, i) => {\n            item.vec = Array.from(resp[i].data);\n            item.tokens = item.embed_input.length;\n            return item;\n          });\n        } catch (err) {\n          console.log(err);\n          console.log(\"Error embedding batch. Trying one at a time...\");\n        }\n        return await Promise.all(items.map(async (item) => {\n          const { vec, tokens: tokens2, error } = await this.embed(item.embed_input);\n          if (error) {\n            console.log(\"Error embedding item: \", item.key);\n            console.log(error);\n            item.error = error;\n            return item;\n          }\n          item.vec = vec;\n          item.tokens = tokens2;\n          return item;\n        }));\n      }\n      async embed(input) {\n        const output = { text: input };\n        if (!input)\n          return { ...output, error: \"No input text.\" };\n        if (!this.model)\n          await this.init();\n        try {\n          output.tokens = await this.count_tokens(input);\n          if (output.tokens < 1)\n            return { ...output, error: \"Input too short.\" };\n          if (output.tokens < 512) {\n            const embedding = await this.model(input, { pooling: \"mean\", normalize: true });\n            output.vec = Array.from(embedding.data);\n          } else {\n            const pct = 512 / output.tokens;\n            const max_chars = Math.floor(input.length * pct * 0.95);\n            input = input.substring(0, max_chars) + \"...\";\n            output.truncated = true;\n            console.log(\"Input too long. Truncating to \", input.length, \" characters.\");\n            const { vec, tokens } = await this.embed(input);\n            output.vec = vec;\n            output.tokens = tokens;\n          }\n          return output;\n        } catch (err) {\n          console.log(err);\n          return { ...output, error: err.message };\n        }\n      }\n      async count_tokens(text) {\n        if (!this.tokenizer)\n          await this.init();\n        const { input_ids } = await this.tokenizer(text);\n        return input_ids.data.length;\n      }\n    };\n    exports.SmartEmbedTransformersNodeAdapter = SmartEmbedTransformersNodeAdapter;\n  }\n});\n\n// SmartEmbedTransformersWebConnector.js\nvar require_SmartEmbedTransformersWebConnector = __commonJS({\n  \"SmartEmbedTransformersWebConnector.js\"(exports) {\n    var { SmartEmbedTransformersNodeAdapter } = require_SmartEmbedTransformersNodeAdapter();\n    var SmartEmbedTransformersWebConnector = class extends SmartEmbedTransformersNodeAdapter {\n      constructor() {\n        super();\n        this.model = null;\n        this.running_init = false;\n        this.window = null;\n        this.embed_ct = 0;\n        this.timestamp = null;\n        this.tokens = 0;\n      }\n      async init() {\n        if (this.model)\n          return console.log(\"Smart Local Model already loaded\");\n        if (this.running_init)\n          await new Promise((resolve) => setTimeout(resolve, 3e3));\n        if (!this.model && !this.running_init)\n          this.running_init = true;\n        console.log(\"Loading Smart Local Model\");\n        const { pipeline, env, AutoTokenizer } = await import(\"https://cdn.jsdelivr.net/npm/@xenova/transformers@2.13.0\");\n        env.allowLocalModels = false;\n        this.model = await pipeline(\"feature-extraction\", this.model_name, { quantized: true });\n        this.tokenizer = await AutoTokenizer.from_pretrained(this.model_name);\n        this.running_init = false;\n        this.window.tokenizer = this.tokenizer;\n        console.log(await this.embed(\"test\"));\n        this.window.parent.postMessage({ type: \"model_loaded\", data: true }, \"*\");\n        this.window.addEventListener(\"message\", this.handle_ipc.bind(this), false);\n      }\n      async handle_ipc(event) {\n        if (event.data.type == \"smart_embed\")\n          this.embed_handler(event.data);\n        if (event.data.type == \"smart_embed_token_ct\")\n          this.count_tokens_handler(event.data.embed_input);\n      }\n      async embed_handler(event_data) {\n        const { embed_input, handler_id } = event_data;\n        if (!this.timestamp)\n          this.timestamp = Date.now();\n        if (Array.isArray(embed_input)) {\n          const resp = await this.embed_batch(embed_input);\n          const send_data = {\n            type: \"smart_embed_resp\",\n            handler_id,\n            data: resp\n          };\n          this.window.postMessage(send_data, \"*\");\n          this.tokens += resp.reduce((acc, item) => acc + item.tokens, 0);\n          this.embed_ct += resp.length;\n        } else {\n          if (!this.timestamp)\n            this.timestamp = Date.now();\n          const send_data = await this.embed(embed_input);\n          send_data.type = \"smart_embed_resp\";\n          if (handler_id)\n            send_data.handler_id = handler_id;\n          this.window.postMessage(send_data, \"*\");\n          this.tokens += send_data.tokens;\n          this.embed_ct++;\n        }\n        if (Date.now() - this.timestamp > 1e4) {\n          console.log(`Embedded: ${this.embed_ct} inputs (${this.tokens} tokens, ${(this.tokens / ((Date.now() - this.timestamp) / 1e3)).toFixed(0)} tokens/sec)`);\n          this.timestamp = null;\n          this.tokens = 0;\n          this.embed_ct = 0;\n        }\n      }\n      async count_tokens_handler(input) {\n        const output = await this.count_tokens(input);\n        const send_data = {\n          type: \"smart_embed_token_ct\",\n          text: \"count:\" + input,\n          count: output\n        };\n        this.window.postMessage(send_data, \"*\");\n      }\n    };\n    exports.SmartEmbedTransformersWebConnector = SmartEmbedTransformersWebConnector;\n  }\n});\n\n// smart_embed_web.js\nwindow.addEventListener(\"message\", init);\nasync function init(event) {\n  if (event.data.type === \"init\") {\n    window.removeEventListener(\"message\", init);\n    const model_name = event.data.model_name;\n    const { SmartEmbedTransformersWebConnector } = await Promise.resolve().then(() => __toESM(require_SmartEmbedTransformersWebConnector()));\n    const model = new SmartEmbedTransformersWebConnector();\n    model.model_name = model_name;\n    model.window = window;\n    await model.init();\n    window.model = model;\n  }\n}\n//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiU21hcnRFbWJlZC5qcyIsICJTbWFydEVtYmVkVHJhbnNmb3JtZXJzTm9kZUFkYXB0ZXIuanMiLCAiU21hcnRFbWJlZFRyYW5zZm9ybWVyc1dlYkNvbm5lY3Rvci5qcyIsICJzbWFydF9lbWJlZF93ZWIuanMiXSwKICAic291cmNlc0NvbnRlbnQiOiBbImNsYXNzIFNtYXJ0RW1iZWQge1xuICBzdGF0aWMgYXN5bmMgY3JlYXRlKCkge1xuICAgIGNvbnN0IGFkYXB0ZXIgPSBuZXcgdGhpcygpO1xuICAgIGF3YWl0IGFkYXB0ZXIuaW5pdCgpO1xuICAgIHJldHVybiBhZGFwdGVyO1xuICB9XG4gIGFzeW5jIGluaXQoKSB7IH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpbnB1dFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxudW1iZXI+fVxuICAgKi9cbiAgYXN5bmMgY291bnRfdG9rZW5zKGlucHV0KSB7IH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpbnB1dFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxudW1iZXJbXT59XG4gICAqL1xuICBhc3luYyBlbWJlZChpbnB1dCkgeyB9XG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBpbnB1dFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxudW1iZXJbXVtdPn1cbiAgICovXG4gIGFzeW5jIGVtYmVkX2JhdGNoKGlucHV0KSB7IH1cbn1cblxuZXhwb3J0cy5TbWFydEVtYmVkID0gU21hcnRFbWJlZDsiLCAiY29uc3QgeyBTbWFydEVtYmVkIH0gPSByZXF1aXJlKFwiLi9TbWFydEVtYmVkXCIpO1xuXG5jbGFzcyBTbWFydEVtYmVkVHJhbnNmb3JtZXJzTm9kZUFkYXB0ZXIgZXh0ZW5kcyBTbWFydEVtYmVkIHtcbiAgYXN5bmMgaW5pdChtb2RlbF9uYW1lID0gJ1hlbm92YS9iZ2Utc21hbGwtZW4tdjEuNScpIHtcbiAgICBjb25zdCB7IGVudiwgcGlwZWxpbmUsIEF1dG9Ub2tlbml6ZXIgfSA9IGF3YWl0IGltcG9ydCgnQHhlbm92YS90cmFuc2Zvcm1lcnMnKTtcbiAgICBlbnYuYWxsb3dMb2NhbE1vZGVscyA9IGZhbHNlO1xuICAgIHRoaXMubW9kZWwgPSBhd2FpdCBwaXBlbGluZSgnZmVhdHVyZS1leHRyYWN0aW9uJywgbW9kZWxfbmFtZSwgeyBxdWFudGl6ZWQ6IHRydWUgfSk7XG4gICAgdGhpcy50b2tlbml6ZXIgPSBhd2FpdCBBdXRvVG9rZW5pemVyLmZyb21fcHJldHJhaW5lZChtb2RlbF9uYW1lKTsgLy8gYmdlXG4gIH1cbiAgYXN5bmMgZW1iZWRfYmF0Y2goaXRlbXMpIHtcbiAgICBjb25zdCB0b2tlbnMgPSBhd2FpdCBQcm9taXNlLmFsbChpdGVtcy5tYXAoaXRlbSA9PiB0aGlzLmNvdW50X3Rva2VucyhpdGVtLmVtYmVkX2lucHV0KSkpO1xuICAgIGNvbnN0IGVtYmVkX2lucHV0ID0gaXRlbXMubWFwKChpdGVtLCBpKSA9PiB7XG4gICAgICBpZiAodG9rZW5zW2ldIDwgNTEyKSByZXR1cm4gaXRlbS5lbWJlZF9pbnB1dDtcbiAgICAgIGNvbnN0IHBjdCA9IDUxMiAvIHRva2Vuc1tpXTsgLy8gZ2V0IHBjdCBvZiBpbnB1dCB0byBrZWVwXG4gICAgICBjb25zdCBtYXhfY2hhcnMgPSBNYXRoLmZsb29yKGl0ZW0uZW1iZWRfaW5wdXQubGVuZ3RoICogcGN0ICogMC45NSk7IC8vIGdldCBudW1iZXIgb2YgY2hhcmFjdGVycyB0byBrZWVwIChtaW51cyA1JSBmb3Igc2FmZXR5KVxuICAgICAgcmV0dXJuIGl0ZW0uZW1iZWRfaW5wdXQuc3Vic3RyaW5nKDAsIG1heF9jaGFycykgKyBcIi4uLlwiO1xuICAgIH0pO1xuICAgIC8vIGNvbnNvbGUubG9nKGVtYmVkX2lucHV0KTtcbiAgICB0cnl7XG4gICAgICBjb25zdCByZXNwID0gYXdhaXQgdGhpcy5tb2RlbChlbWJlZF9pbnB1dCwgeyBwb29saW5nOiAnbWVhbicsIG5vcm1hbGl6ZTogdHJ1ZSB9KTtcbiAgICAgIC8vIGNvbnNvbGUubG9nKHJlc3ApO1xuICAgICAgcmV0dXJuIGl0ZW1zLm1hcCgoaXRlbSwgaSkgPT4ge1xuICAgICAgICBpdGVtLnZlYyA9IEFycmF5LmZyb20ocmVzcFtpXS5kYXRhKTtcbiAgICAgICAgaXRlbS50b2tlbnMgPSBpdGVtLmVtYmVkX2lucHV0Lmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICB9KTtcbiAgICB9Y2F0Y2goZXJyKXtcbiAgICAgIGNvbnNvbGUubG9nKGVycik7XG4gICAgICBjb25zb2xlLmxvZyhcIkVycm9yIGVtYmVkZGluZyBiYXRjaC4gVHJ5aW5nIG9uZSBhdCBhIHRpbWUuLi5cIik7XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCBQcm9taXNlLmFsbChpdGVtcy5tYXAoYXN5bmMgaXRlbSA9PiB7XG4gICAgICBjb25zdCB7IHZlYywgdG9rZW5zLCBlcnJvciB9ID0gYXdhaXQgdGhpcy5lbWJlZChpdGVtLmVtYmVkX2lucHV0KTtcbiAgICAgIGlmKGVycm9yKXtcbiAgICAgICAgY29uc29sZS5sb2coXCJFcnJvciBlbWJlZGRpbmcgaXRlbTogXCIsIGl0ZW0ua2V5KTtcbiAgICAgICAgY29uc29sZS5sb2coZXJyb3IpO1xuICAgICAgICBpdGVtLmVycm9yID0gZXJyb3I7XG4gICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgfVxuICAgICAgaXRlbS52ZWMgPSB2ZWM7XG4gICAgICBpdGVtLnRva2VucyA9IHRva2VucztcbiAgICAgIHJldHVybiBpdGVtO1xuICAgIH0pKTtcbiAgfVxuICBhc3luYyBlbWJlZChpbnB1dCkge1xuICAgIGNvbnN0IG91dHB1dCA9IHsgdGV4dDogaW5wdXQgfTtcbiAgICBpZiAoIWlucHV0KSByZXR1cm4geyAuLi5vdXRwdXQsIGVycm9yOiBcIk5vIGlucHV0IHRleHQuXCIgfTtcbiAgICBpZiAoIXRoaXMubW9kZWwpIGF3YWl0IHRoaXMuaW5pdCgpO1xuICAgIHRyeSB7XG4gICAgICBvdXRwdXQudG9rZW5zID0gYXdhaXQgdGhpcy5jb3VudF90b2tlbnMoaW5wdXQpO1xuICAgICAgaWYgKG91dHB1dC50b2tlbnMgPCAxKSByZXR1cm4geyAuLi5vdXRwdXQsIGVycm9yOiBcIklucHV0IHRvbyBzaG9ydC5cIiB9O1xuICAgICAgaWYgKG91dHB1dC50b2tlbnMgPCA1MTIpIHtcbiAgICAgICAgY29uc3QgZW1iZWRkaW5nID0gYXdhaXQgdGhpcy5tb2RlbChpbnB1dCwgeyBwb29saW5nOiAnbWVhbicsIG5vcm1hbGl6ZTogdHJ1ZSB9KTtcbiAgICAgICAgb3V0cHV0LnZlYyA9IEFycmF5LmZyb20oZW1iZWRkaW5nLmRhdGEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgcGN0ID0gNTEyIC8gb3V0cHV0LnRva2VuczsgLy8gZ2V0IHBjdCBvZiBpbnB1dCB0byBrZWVwXG4gICAgICAgIGNvbnN0IG1heF9jaGFycyA9IE1hdGguZmxvb3IoaW5wdXQubGVuZ3RoICogcGN0ICogMC45NSk7IC8vIGdldCBudW1iZXIgb2YgY2hhcmFjdGVycyB0byBrZWVwIChtaW51cyA1JSBmb3Igc2FmZXR5KVxuICAgICAgICBpbnB1dCA9IGlucHV0LnN1YnN0cmluZygwLCBtYXhfY2hhcnMpICsgXCIuLi5cIjtcbiAgICAgICAgb3V0cHV0LnRydW5jYXRlZCA9IHRydWU7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiSW5wdXQgdG9vIGxvbmcuIFRydW5jYXRpbmcgdG8gXCIsIGlucHV0Lmxlbmd0aCwgXCIgY2hhcmFjdGVycy5cIik7XG4gICAgICAgIGNvbnN0IHsgdmVjLCB0b2tlbnMgfSA9IGF3YWl0IHRoaXMuZW1iZWQoaW5wdXQpO1xuICAgICAgICBvdXRwdXQudmVjID0gdmVjO1xuICAgICAgICBvdXRwdXQudG9rZW5zID0gdG9rZW5zO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUubG9nKGVycik7XG4gICAgICByZXR1cm4geyAuLi5vdXRwdXQsIGVycm9yOiBlcnIubWVzc2FnZSB9O1xuICAgIH1cbiAgfVxuICBhc3luYyBjb3VudF90b2tlbnModGV4dCkge1xuICAgIGlmICghdGhpcy50b2tlbml6ZXIpIGF3YWl0IHRoaXMuaW5pdCgpO1xuICAgIGNvbnN0IHsgaW5wdXRfaWRzIH0gPSBhd2FpdCB0aGlzLnRva2VuaXplcih0ZXh0KTtcbiAgICByZXR1cm4gaW5wdXRfaWRzLmRhdGEubGVuZ3RoOyAvLyBSZXR1cm4gdGhlIG51bWJlciBvZiB0b2tlbnNcbiAgfVxufVxuXG5leHBvcnRzLlNtYXJ0RW1iZWRUcmFuc2Zvcm1lcnNOb2RlQWRhcHRlciA9IFNtYXJ0RW1iZWRUcmFuc2Zvcm1lcnNOb2RlQWRhcHRlcjsiLCAiY29uc3QgeyBTbWFydEVtYmVkVHJhbnNmb3JtZXJzTm9kZUFkYXB0ZXIgfSA9IHJlcXVpcmUoJy4vU21hcnRFbWJlZFRyYW5zZm9ybWVyc05vZGVBZGFwdGVyJyk7XG5cbi8vIENPTk5FQ1RPUiBGT1IgT0JTSURJQU5cbmNsYXNzIFNtYXJ0RW1iZWRUcmFuc2Zvcm1lcnNXZWJDb25uZWN0b3IgZXh0ZW5kcyBTbWFydEVtYmVkVHJhbnNmb3JtZXJzTm9kZUFkYXB0ZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMubW9kZWwgPSBudWxsO1xuICAgIHRoaXMucnVubmluZ19pbml0ID0gZmFsc2U7XG4gICAgdGhpcy53aW5kb3cgPSBudWxsO1xuICAgIC8vIHN0YXRzXG4gICAgdGhpcy5lbWJlZF9jdCA9IDA7XG4gICAgdGhpcy50aW1lc3RhbXAgPSBudWxsO1xuICAgIHRoaXMudG9rZW5zID0gMDtcbiAgfVxuICBhc3luYyBpbml0KCkge1xuICAgIGlmICh0aGlzLm1vZGVsKSByZXR1cm4gY29uc29sZS5sb2coXCJTbWFydCBMb2NhbCBNb2RlbCBhbHJlYWR5IGxvYWRlZFwiKTtcbiAgICBpZiAodGhpcy5ydW5uaW5nX2luaXQpIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAzMDAwKSk7XG4gICAgaWYgKCF0aGlzLm1vZGVsICYmICF0aGlzLnJ1bm5pbmdfaW5pdCkgdGhpcy5ydW5uaW5nX2luaXQgPSB0cnVlO1xuICAgIGNvbnNvbGUubG9nKFwiTG9hZGluZyBTbWFydCBMb2NhbCBNb2RlbFwiKTtcbiAgICBjb25zdCB7IHBpcGVsaW5lLCBlbnYsIEF1dG9Ub2tlbml6ZXIgfSA9IGF3YWl0IGltcG9ydCgnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9AeGVub3ZhL3RyYW5zZm9ybWVyc0AyLjEzLjAnKTtcbiAgICBlbnYuYWxsb3dMb2NhbE1vZGVscyA9IGZhbHNlO1xuICAgIHRoaXMubW9kZWwgPSBhd2FpdCBwaXBlbGluZSgnZmVhdHVyZS1leHRyYWN0aW9uJywgdGhpcy5tb2RlbF9uYW1lLCB7IHF1YW50aXplZDogdHJ1ZSB9KTtcbiAgICB0aGlzLnRva2VuaXplciA9IGF3YWl0IEF1dG9Ub2tlbml6ZXIuZnJvbV9wcmV0cmFpbmVkKHRoaXMubW9kZWxfbmFtZSk7XG4gICAgdGhpcy5ydW5uaW5nX2luaXQgPSBmYWxzZTtcbiAgICB0aGlzLndpbmRvdy50b2tlbml6ZXIgPSB0aGlzLnRva2VuaXplcjtcbiAgICBjb25zb2xlLmxvZyhhd2FpdCB0aGlzLmVtYmVkKFwidGVzdFwiKSk7XG4gICAgdGhpcy53aW5kb3cucGFyZW50LnBvc3RNZXNzYWdlKHsgdHlwZTogXCJtb2RlbF9sb2FkZWRcIiwgZGF0YTogdHJ1ZSB9LCBcIipcIik7IC8vIHBvc3QgbWVzc2FnZSB0byBwYXJlbnQgdGhhdCBtb2RlbCBpcyBsb2FkZWRcbiAgICB0aGlzLndpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCB0aGlzLmhhbmRsZV9pcGMuYmluZCh0aGlzKSwgZmFsc2UpO1xuICB9XG4gIGFzeW5jIGhhbmRsZV9pcGMoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQuZGF0YS50eXBlID09IFwic21hcnRfZW1iZWRcIikgdGhpcy5lbWJlZF9oYW5kbGVyKGV2ZW50LmRhdGEpO1xuICAgIC8vIGlmIChldmVudC5kYXRhLnR5cGUgPT0gXCJzbWFydF9lbWJlZF9iYXRjaFwiKSB0aGlzLmVtYmVkX2JhdGNoX2hhbmRsZXIoZXZlbnQuZGF0YS5lbWJlZF9pbnB1dCk7XG4gICAgaWYgKGV2ZW50LmRhdGEudHlwZSA9PSBcInNtYXJ0X2VtYmVkX3Rva2VuX2N0XCIpIHRoaXMuY291bnRfdG9rZW5zX2hhbmRsZXIoZXZlbnQuZGF0YS5lbWJlZF9pbnB1dCk7XG4gIH1cbiAgYXN5bmMgZW1iZWRfaGFuZGxlcihldmVudF9kYXRhKSB7XG4gICAgY29uc3QgeyBlbWJlZF9pbnB1dCwgaGFuZGxlcl9pZCB9ID0gZXZlbnRfZGF0YTtcbiAgICAvLyBjb25zb2xlLmxvZyhlbWJlZF9pbnB1dCk7XG4gICAgaWYoIXRoaXMudGltZXN0YW1wKSB0aGlzLnRpbWVzdGFtcCA9IERhdGUubm93KCk7XG4gICAgaWYoQXJyYXkuaXNBcnJheShlbWJlZF9pbnB1dCkpIHtcbiAgICAgIGNvbnN0IHJlc3AgPSBhd2FpdCB0aGlzLmVtYmVkX2JhdGNoKGVtYmVkX2lucHV0KTtcbiAgICAgIGNvbnN0IHNlbmRfZGF0YSA9IHtcbiAgICAgICAgdHlwZTogXCJzbWFydF9lbWJlZF9yZXNwXCIsXG4gICAgICAgIGhhbmRsZXJfaWQsXG4gICAgICAgIGRhdGE6IHJlc3AsXG4gICAgICB9O1xuICAgICAgdGhpcy53aW5kb3cucG9zdE1lc3NhZ2Uoc2VuZF9kYXRhLCBcIipcIik7XG4gICAgICB0aGlzLnRva2VucyArPSByZXNwLnJlZHVjZSgoYWNjLCBpdGVtKSA9PiBhY2MgKyBpdGVtLnRva2VucywgMCk7XG4gICAgICB0aGlzLmVtYmVkX2N0ICs9IHJlc3AubGVuZ3RoO1xuICAgIH1lbHNle1xuICAgICAgaWYgKCF0aGlzLnRpbWVzdGFtcCkgdGhpcy50aW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuICAgICAgY29uc3Qgc2VuZF9kYXRhID0gYXdhaXQgdGhpcy5lbWJlZChlbWJlZF9pbnB1dCk7XG4gICAgICBzZW5kX2RhdGEudHlwZSA9IFwic21hcnRfZW1iZWRfcmVzcFwiO1xuICAgICAgaWYgKGhhbmRsZXJfaWQpIHNlbmRfZGF0YS5oYW5kbGVyX2lkID0gaGFuZGxlcl9pZDtcbiAgICAgIHRoaXMud2luZG93LnBvc3RNZXNzYWdlKHNlbmRfZGF0YSwgXCIqXCIpO1xuICAgICAgdGhpcy50b2tlbnMgKz0gc2VuZF9kYXRhLnRva2VucztcbiAgICAgIHRoaXMuZW1iZWRfY3QrKztcbiAgICB9XG4gICAgaWYgKERhdGUubm93KCkgLSB0aGlzLnRpbWVzdGFtcCA+IDEwMDAwKSB7XG4gICAgICBjb25zb2xlLmxvZyhgRW1iZWRkZWQ6ICR7dGhpcy5lbWJlZF9jdH0gaW5wdXRzICgke3RoaXMudG9rZW5zfSB0b2tlbnMsICR7KHRoaXMudG9rZW5zIC8gKChEYXRlLm5vdygpIC0gdGhpcy50aW1lc3RhbXApIC8gMTAwMCkpLnRvRml4ZWQoMCl9IHRva2Vucy9zZWMpYCk7XG4gICAgICB0aGlzLnRpbWVzdGFtcCA9IG51bGw7XG4gICAgICB0aGlzLnRva2VucyA9IDA7XG4gICAgICB0aGlzLmVtYmVkX2N0ID0gMDtcbiAgICB9XG4gIH1cbiAgYXN5bmMgY291bnRfdG9rZW5zX2hhbmRsZXIoaW5wdXQpIHtcbiAgICBjb25zdCBvdXRwdXQgPSBhd2FpdCB0aGlzLmNvdW50X3Rva2VucyhpbnB1dCk7XG4gICAgY29uc3Qgc2VuZF9kYXRhID0ge1xuICAgICAgdHlwZTogXCJzbWFydF9lbWJlZF90b2tlbl9jdFwiLFxuICAgICAgdGV4dDogXCJjb3VudDpcIiArIGlucHV0LFxuICAgICAgY291bnQ6IG91dHB1dFxuICAgIH07XG4gICAgdGhpcy53aW5kb3cucG9zdE1lc3NhZ2Uoc2VuZF9kYXRhLCBcIipcIik7XG4gIH1cbn1cbmV4cG9ydHMuU21hcnRFbWJlZFRyYW5zZm9ybWVyc1dlYkNvbm5lY3RvciA9IFNtYXJ0RW1iZWRUcmFuc2Zvcm1lcnNXZWJDb25uZWN0b3I7IiwgIndpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgaW5pdCk7IC8vIGxpc3RlbiBmb3IgaW5pdCBtZXNzYWdlXG5hc3luYyBmdW5jdGlvbiBpbml0KGV2ZW50KSB7XG4gIGlmIChldmVudC5kYXRhLnR5cGUgPT09ICdpbml0Jykge1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgaW5pdCk7IC8vIHJlbW92ZSB0aGlzIGV2ZW50IGxpc3RlbmVyXG4gICAgY29uc3QgbW9kZWxfbmFtZSA9IGV2ZW50LmRhdGEubW9kZWxfbmFtZTtcbiAgICBjb25zdCB7IFNtYXJ0RW1iZWRUcmFuc2Zvcm1lcnNXZWJDb25uZWN0b3IgfSA9IGF3YWl0IGltcG9ydCgnLi9TbWFydEVtYmVkVHJhbnNmb3JtZXJzV2ViQ29ubmVjdG9yLmpzJyk7XG4gICAgY29uc3QgbW9kZWwgPSBuZXcgU21hcnRFbWJlZFRyYW5zZm9ybWVyc1dlYkNvbm5lY3RvcigpO1xuICAgIG1vZGVsLm1vZGVsX25hbWUgPSBtb2RlbF9uYW1lO1xuICAgIG1vZGVsLndpbmRvdyA9IHdpbmRvdztcbiAgICBhd2FpdCBtb2RlbC5pbml0KCk7XG4gICAgd2luZG93Lm1vZGVsID0gbW9kZWw7XG4gIH1cbn0iXSwKICAibWFwcGluZ3MiOiAiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUFBO0FBQUEsUUFBTSxhQUFOLE1BQWlCO0FBQUEsTUFDZixhQUFhLFNBQVM7QUFDcEIsY0FBTSxVQUFVLElBQUksS0FBSztBQUN6QixjQUFNLFFBQVEsS0FBSztBQUNuQixlQUFPO0FBQUEsTUFDVDtBQUFBLE1BQ0EsTUFBTSxPQUFPO0FBQUEsTUFBRTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFLZixNQUFNLGFBQWEsT0FBTztBQUFBLE1BQUU7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BSzVCLE1BQU0sTUFBTSxPQUFPO0FBQUEsTUFBRTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFLckIsTUFBTSxZQUFZLE9BQU87QUFBQSxNQUFFO0FBQUEs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\n"
}