{
  "script": "var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __commonJS = (cb, mod) => function __require() {\n  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\n\n// models.json\nvar require_models = __commonJS({\n  \"models.json\"(exports, module2) {\n    module2.exports = {\n      \"TaylorAI/bge-micro-v2\": {\n        model_name: \"TaylorAI/bge-micro-v2\",\n        batch_size: 1,\n        dims: 384,\n        max_tokens: 512,\n        name: \"BGE-micro-v2\",\n        description: \"Local, 512 tokens, 384 dim\",\n        type: \"huggingface-transformers\"\n      },\n      \"Xenova/bge-small-en-v1.5\": {\n        model_name: \"Xenova/bge-small-en-v1.5\",\n        batch_size: 1,\n        dims: 384,\n        max_tokens: 512,\n        name: \"BGE-small\",\n        description: \"Local, 512 tokens, 384 dim\",\n        type: \"huggingface-transformers\"\n      },\n      \"Xenova/jina-embeddings-v2-small-en-2048\": {\n        model_name: \"Xenova/jina-embeddings-v2-small-en\",\n        batch_size: 1,\n        dims: 512,\n        max_tokens: 2048,\n        name: \"Jina-v2-small-2K\",\n        description: \"Local, 2,048 tokens, 512 dim\",\n        type: \"huggingface-transformers\"\n      },\n      \"Xenova/jina-embeddings-v2-small-en-4096\": {\n        model_name: \"Xenova/jina-embeddings-v2-small-en\",\n        batch_size: 1,\n        dims: 512,\n        max_tokens: 4096,\n        name: \"Jina-v2-small-4K\",\n        description: \"Local, 4,096 tokens, 512 dim\",\n        type: \"huggingface-transformers\"\n      },\n      \"Xenova/jina-embeddings-v2-small-en-8192\": {\n        model_name: \"Xenova/jina-embeddings-v2-small-en\",\n        batch_size: 1,\n        dims: 512,\n        max_tokens: 8192,\n        name: \"Jina-v2-small-8K\",\n        description: \"Local, 8,192 tokens, 512 dim\",\n        type: \"huggingface-transformers\"\n      },\n      \"text-embedding-3-small\": {\n        model_name: \"text-embedding-3-small\",\n        batch_size: 50,\n        dims: 1536,\n        max_tokens: 8191,\n        name: \"OpenAI Text-3 Small\",\n        description: \"API, 8,191 tokens, 1,536 dim\",\n        type: \"openai\"\n      },\n      \"text-embedding-3-large\": {\n        model_name: \"text-embedding-3-large\",\n        batch_size: 50,\n        dims: 3072,\n        max_tokens: 8191,\n        name: \"OpenAI Text-3 Large\",\n        description: \"API, 8,191 tokens, 3,072 dim\",\n        type: \"openai\"\n      },\n      \"text-embedding-3-small-512\": {\n        model_name: \"text-embedding-3-small\",\n        batch_size: 50,\n        dims: 512,\n        max_tokens: 8191,\n        name: \"OpenAI Text-3 Small - 512\",\n        description: \"API, 8,191 tokens, 512 dim\",\n        type: \"openai\"\n      },\n      \"text-embedding-3-large-256\": {\n        model_name: \"text-embedding-3-large\",\n        batch_size: 50,\n        dims: 256,\n        max_tokens: 8191,\n        name: \"OpenAI Text-3 Large - 256\",\n        description: \"API, 8,191 tokens, 256 dim\",\n        type: \"openai\"\n      },\n      \"text-embedding-ada-002\": {\n        model_name: \"text-embedding-ada-002\",\n        batch_size: 50,\n        dims: 1536,\n        max_tokens: 8191,\n        name: \"OpenAI Ada\",\n        description: \"API, 8,191 tokens, 1,536 dim\",\n        type: \"openai\"\n      }\n    };\n  }\n});\n\n// SmartEmbed.js\nvar require_SmartEmbed = __commonJS({\n  \"SmartEmbed.js\"(exports) {\n    var models = require_models();\n    var SmartEmbed = class {\n      constructor(model_config_key) {\n        this.model_config_key = model_config_key;\n        this.config = models[this.model_config_key];\n      }\n      static async create(model_config_key, ...args) {\n        const adapter = new this(model_config_key, ...args);\n        await adapter.init();\n        return adapter;\n      }\n      async init() {\n      }\n      /**\n       * @param {string} input\n       * @returns {Promise<number>}\n       */\n      async count_tokens(input) {\n      }\n      /**\n       * @param {string} input\n       * @returns {Promise<number[]>}\n       */\n      async embed(input) {\n      }\n      /**\n       * @param {string[]} input\n       * @returns {Promise<number[][]>}\n       */\n      async embed_batch(input) {\n      }\n      get batch_size() {\n        return this.config.batch_size;\n      }\n      get dims() {\n        return this.config.dims;\n      }\n      get max_tokens() {\n        return this.config.max_tokens;\n      }\n      get model_name() {\n        return this.config.model_name;\n      }\n    };\n    exports.SmartEmbed = SmartEmbed;\n  }\n});\n\n// SmartEmbedTransformersNodeAdapter.js\nvar require_SmartEmbedTransformersNodeAdapter = __commonJS({\n  \"SmartEmbedTransformersNodeAdapter.js\"(exports) {\n    var { SmartEmbed } = require_SmartEmbed();\n    var SmartEmbedTransformersNodeAdapter = class extends SmartEmbed {\n      // async init(this.model_name = 'Xenova/bge-small-en-v1.5') {\n      async init() {\n        const { env, pipeline, AutoTokenizer } = await import(\"@xenova/transformers\");\n        env.allowLocalModels = false;\n        this.model = await pipeline(\"feature-extraction\", this.model_name, { quantized: true, max_length: this.config.max_tokens });\n        this.tokenizer = await AutoTokenizer.from_pretrained(this.model_name);\n      }\n      async embed_batch(items) {\n        items = items.filter((item) => {\n          var _a;\n          return ((_a = item.embed_input) == null ? void 0 : _a.length) > 0;\n        });\n        if (!(items == null ? void 0 : items.length))\n          return [];\n        const tokens = await Promise.all(items.map((item) => this.count_tokens(item.embed_input)));\n        const embed_input = await Promise.all(items.map(async (item, i) => {\n          if (tokens[i] < this.config.max_tokens)\n            return item.embed_input;\n          let token_ct = tokens[i];\n          let truncated_input = item.embed_input;\n          while (token_ct > this.config.max_tokens) {\n            const pct = this.config.max_tokens / token_ct;\n            const max_chars = Math.floor(truncated_input.length * pct * 0.9);\n            truncated_input = truncated_input.substring(0, max_chars) + \"...\";\n            token_ct = await this.count_tokens(truncated_input);\n          }\n          console.log(\"Input too long. Truncating to \", truncated_input.length, \" characters.\");\n          console.log(\"Tokens: \", tokens[i], \" -> \", token_ct);\n          tokens[i] = token_ct;\n          return truncated_input;\n        }));\n        try {\n          const resp = await this.model(embed_input, { pooling: \"mean\", normalize: true });\n          return items.map((item, i) => {\n            item.vec = Array.from(resp[i].data);\n            item.tokens = tokens[i];\n            return item;\n          });\n        } catch (err) {\n          console.log(err);\n          console.log(\"Error embedding batch. Trying one at a time...\");\n        }\n        return await Promise.all(items.map(async (item) => {\n          const { vec, tokens: tokens2, error } = await this.embed(item.embed_input);\n          if (error) {\n            console.log(\"Error embedding item: \", item.key);\n            console.log(error);\n            item.error = error;\n            return item;\n          }\n          if (!vec) {\n            console.log(\"Error embedding item: \", item.key);\n            console.log(\"Vec: \", vec);\n            console.log(\"Error: \", error);\n            console.log(\"Tokens: \", tokens2);\n            console.log(\"No vec returned\");\n            item.error = \"No vec returned\";\n            return item;\n          }\n          item.vec = vec.map((val) => Math.round(val * 1e8) / 1e8);\n          item.tokens = tokens2;\n          return item;\n        }));\n      }\n      async embed(input) {\n        const output = { embed_input: input };\n        if (!input)\n          return { ...output, error: \"No input text.\" };\n        if (!this.model)\n          await this.init();\n        try {\n          output.tokens = await this.count_tokens(input);\n          if (output.tokens < 1)\n            return { ...output, error: \"Input too short.\" };\n          if (output.tokens < this.config.max_tokens) {\n            const embedding = await this.model(input, { pooling: \"mean\", normalize: true });\n            output.vec = Array.from(embedding.data).map((val) => Math.round(val * 1e8) / 1e8);\n          } else {\n            const pct = this.config.max_tokens / output.tokens;\n            const max_chars = Math.floor(input.length * pct * 0.95);\n            input = input.substring(0, max_chars) + \"...\";\n            output.truncated = true;\n            console.log(\"Input too long. Truncating to \", input.length, \" characters.\");\n            const { vec, tokens } = await this.embed(input);\n            output.vec = vec;\n            output.tokens = tokens;\n          }\n          return output;\n        } catch (err) {\n          console.log(err);\n          return { ...output, error: err.message };\n        }\n      }\n      async count_tokens(text) {\n        if (!this.tokenizer)\n          await this.init();\n        const { input_ids } = await this.tokenizer(text);\n        return input_ids.data.length;\n      }\n    };\n    exports.SmartEmbedTransformersNodeAdapter = SmartEmbedTransformersNodeAdapter;\n    exports.SmartEmbedLocalAdapter = SmartEmbedTransformersNodeAdapter;\n  }\n});\n\n// SmartEmbedTransformersWebConnector.js\nvar require_SmartEmbedTransformersWebConnector = __commonJS({\n  \"SmartEmbedTransformersWebConnector.js\"(exports) {\n    var { SmartEmbedTransformersNodeAdapter } = require_SmartEmbedTransformersNodeAdapter();\n    var models = require_models();\n    var SmartEmbedTransformersWebConnector = class extends SmartEmbedTransformersNodeAdapter {\n      constructor(model_config_key, window2) {\n        super(model_config_key);\n        this.model = null;\n        this.running_init = false;\n        this.window = window2;\n        this.embed_ct = 0;\n        this.timestamp = null;\n        this.tokens = 0;\n      }\n      async init() {\n        if (this.model)\n          return console.log(\"Smart Local Model already loaded\");\n        if (this.running_init)\n          await new Promise((resolve) => setTimeout(resolve, 3e3));\n        if (!this.model && !this.running_init)\n          this.running_init = true;\n        console.log(\"Loading Smart Local Model\");\n        const { pipeline, env, AutoTokenizer } = await import(\"https://cdn.jsdelivr.net/npm/@xenova/transformers@latest\");\n        env.allowLocalModels = false;\n        this.model = await pipeline(\"feature-extraction\", this.model_name, { quantized: true });\n        this.tokenizer = await AutoTokenizer.from_pretrained(this.model_name);\n        this.running_init = false;\n        this.window.tokenizer = this.tokenizer;\n        console.log(await this.embed(\"test\"));\n        this.window.parent.postMessage({ type: \"model_loaded\", data: true }, \"*\");\n        this.window.addEventListener(\"message\", this.handle_ipc.bind(this), false);\n      }\n      async handle_ipc(event) {\n        if (event.data.type == \"smart_embed\")\n          this.embed_handler(event.data);\n        if (event.data.type == \"smart_embed_token_ct\")\n          this.count_tokens_handler(event.data.embed_input);\n      }\n      async embed_handler(event_data) {\n        const { embed_input, handler_id } = event_data;\n        if (!this.timestamp)\n          this.timestamp = Date.now();\n        if (Array.isArray(embed_input)) {\n          const resp = await this.embed_batch(embed_input);\n          const send_data = {\n            type: \"smart_embed_resp\",\n            handler_id,\n            data: resp\n          };\n          this.window.postMessage(send_data, \"*\");\n          this.tokens += resp.reduce((acc, item) => acc + item.tokens, 0);\n          this.embed_ct += resp.length;\n        } else {\n          if (!this.timestamp)\n            this.timestamp = Date.now();\n          const send_data = await this.embed(embed_input);\n          send_data.type = \"smart_embed_resp\";\n          if (handler_id)\n            send_data.handler_id = handler_id;\n          this.window.postMessage(send_data, \"*\");\n          this.tokens += send_data.tokens;\n          this.embed_ct++;\n        }\n        if (Date.now() - this.timestamp > 1e4) {\n          console.log(`Embedded: ${this.embed_ct} inputs (${this.tokens} tokens, ${(this.tokens / ((Date.now() - this.timestamp) / 1e3)).toFixed(0)} tokens/sec)`);\n          this.timestamp = null;\n          this.tokens = 0;\n          this.embed_ct = 0;\n        }\n      }\n      async count_tokens_handler(input) {\n        const output = await this.count_tokens(input);\n        const send_data = {\n          type: \"smart_embed_token_ct\",\n          text: \"count:\" + input,\n          count: output\n        };\n        this.window.postMessage(send_data, \"*\");\n      }\n    };\n    exports.SmartEmbedTransformersWebConnector = SmartEmbedTransformersWebConnector;\n  }\n});\n\n// smart_embed_web.js\nwindow.addEventListener(\"message\", init);\nasync function init(event) {\n  if (event.data.type === \"init\") {\n    window.removeEventListener(\"message\", init);\n    const model_config_key = event.data.model_config_key;\n    const { SmartEmbedTransformersWebConnector } = await Promise.resolve().then(() => __toESM(require_SmartEmbedTransformersWebConnector()));\n    const model = await SmartEmbedTransformersWebConnector.create(model_config_key, window);\n    window.model = model;\n  }\n}\n//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibW9kZWxzLmpzb24iLCAiU21hcnRFbWJlZC5qcyIsICJTbWFydEVtYmVkVHJhbnNmb3JtZXJzTm9kZUFkYXB0ZXIuanMiLCAiU21hcnRFbWJlZFRyYW5zZm9ybWVyc1dlYkNvbm5lY3Rvci5qcyIsICJzbWFydF9lbWJlZF93ZWIuanMiXSwKICAic291cmNlc0NvbnRlbnQiOiBbIntcclxuICBcIlRheWxvckFJL2JnZS1taWNyby12MlwiOiB7XHJcbiAgICBcIm1vZGVsX25hbWVcIjogXCJUYXlsb3JBSS9iZ2UtbWljcm8tdjJcIixcclxuICAgIFwiYmF0Y2hfc2l6ZVwiOiAxLFxyXG4gICAgXCJkaW1zXCI6IDM4NCxcclxuICAgIFwibWF4X3Rva2Vuc1wiOiA1MTIsXHJcbiAgICBcIm5hbWVcIjogXCJCR0UtbWljcm8tdjJcIixcclxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJMb2NhbCwgNTEyIHRva2VucywgMzg0IGRpbVwiLFxyXG4gICAgXCJ0eXBlXCI6IFwiaHVnZ2luZ2ZhY2UtdHJhbnNmb3JtZXJzXCJcclxuICB9LFxyXG4gIFwiWGVub3ZhL2JnZS1zbWFsbC1lbi12MS41XCI6IHtcclxuICAgIFwibW9kZWxfbmFtZVwiOiBcIlhlbm92YS9iZ2Utc21hbGwtZW4tdjEuNVwiLFxyXG4gICAgXCJiYXRjaF9zaXplXCI6IDEsXHJcbiAgICBcImRpbXNcIjogMzg0LFxyXG4gICAgXCJtYXhfdG9rZW5zXCI6IDUxMixcclxuICAgIFwibmFtZVwiOiBcIkJHRS1zbWFsbFwiLFxyXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIkxvY2FsLCA1MTIgdG9rZW5zLCAzODQgZGltXCIsXHJcbiAgICBcInR5cGVcIjogXCJodWdnaW5nZmFjZS10cmFuc2Zvcm1lcnNcIlxyXG4gIH0sXHJcbiAgXCJYZW5vdmEvamluYS1lbWJlZGRpbmdzLXYyLXNtYWxsLWVuLTIwNDhcIjoge1xyXG4gICAgXCJtb2RlbF9uYW1lXCI6IFwiWGVub3ZhL2ppbmEtZW1iZWRkaW5ncy12Mi1zbWFsbC1lblwiLFxyXG4gICAgXCJiYXRjaF9zaXplXCI6IDEsXHJcbiAgICBcImRpbXNcIjogNTEyLFxyXG4gICAgXCJtYXhfdG9rZW5zXCI6IDIwNDgsXHJcbiAgICBcIm5hbWVcIjogXCJKaW5hLXYyLXNtYWxsLTJLXCIsXHJcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiTG9jYWwsIDIsMDQ4IHRva2VucywgNTEyIGRpbVwiLFxyXG4gICAgXCJ0eXBlXCI6IFwiaHVnZ2luZ2ZhY2UtdHJhbnNmb3JtZXJzXCJcclxuICB9LFxyXG4gIFwiWGVub3ZhL2ppbmEtZW1iZWRkaW5ncy12Mi1zbWFsbC1lbi00MDk2XCI6IHtcclxuICAgIFwibW9kZWxfbmFtZVwiOiBcIlhlbm92YS9qaW5hLWVtYmVkZGluZ3MtdjItc21hbGwtZW5cIixcclxuICAgIFwiYmF0Y2hfc2l6ZVwiOiAxLFxyXG4gICAgXCJkaW1zXCI6IDUxMixcclxuICAgIFwibWF4X3Rva2Vuc1wiOiA0MDk2LFxyXG4gICAgXCJuYW1lXCI6IFwiSmluYS12Mi1zbWFsbC00S1wiLFxyXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIkxvY2FsLCA0LDA5NiB0b2tlbnMsIDUxMiBkaW1cIixcclxuICAgIFwidHlwZVwiOiBcImh1Z2dpbmdmYWNlLXRyYW5zZm9ybWVyc1wiXHJcbiAgfSxcclxuICBcIlhlbm92YS9qaW5hLWVtYmVkZGluZ3MtdjItc21hbGwtZW4tODE5MlwiOiB7XHJcbiAgICBcIm1vZGVsX25hbWVcIjogXCJYZW5vdmEvamluYS1lbWJlZGRpbmdzLXYyLXNtYWxsLWVuXCIsXHJcbiAgICBcImJhdGNoX3NpemVcIjogMSxcclxuICAgIFwiZGltc1wiOiA1MTIsXHJcbiAgICBcIm1heF90b2tlbnNcIjogODE5MixcclxuICAgIFwibmFtZVwiOiBcIkppbmEtdjItc21hbGwtOEtcIixcclxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJMb2NhbCwgOCwxOTIgdG9rZW5zLCA1MTIgZGltXCIsXHJcbiAgICBcInR5cGVcIjogXCJodWdnaW5nZmFjZS10cmFuc2Zvcm1lcnNcIlxyXG4gIH0sXHJcbiAgXCJ0ZXh0LWVtYmVkZGluZy0zLXNtYWxsXCI6IHtcclxuICAgIFwibW9kZWxfbmFtZVwiOiBcInRleHQtZW1iZWRkaW5nLTMtc21hbGxcIixcclxuICAgIFwiYmF0Y2hfc2l6ZVwiOiA1MCxcclxuICAgIFwiZGltc1wiOiAxNTM2LFxyXG4gICAgXCJtYXhfdG9rZW5zXCI6IDgxOTEsXHJcbiAgICBcIm5hbWVcIjogXCJPcGVuQUkgVGV4dC0zIFNtYWxsXCIsXHJcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiQVBJLCA4LDE5MSB0b2tlbnMsIDEsNTM2IGRpbVwiLFxyXG4gICAgXCJ0eXBlXCI6IFwib3BlbmFpXCJcclxuICB9LFxyXG4gIFwidGV4dC1lbWJlZGRpbmctMy1sYXJnZVwiOiB7XHJcbiAgICBcIm1vZGVsX25hbWVcIjogXCJ0ZXh0LWVtYmVkZGluZy0zLWxhcmdlXCIsXHJcbiAgICBcImJhdGNoX3NpemVcIjogNTAsXHJcbiAgICBcImRpbXNcIjogMzA3MixcclxuICAgIFwibWF4X3Rva2Vuc1wiOiA4MTkxLFxyXG4gICAgXCJuYW1lXCI6IFwiT3BlbkFJIFRleHQtMyBMYXJnZVwiLFxyXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIkFQSSwgOCwxOTEgdG9rZW5zLCAzLDA3MiBkaW1cIixcclxuICAgIFwidHlwZVwiOiBcIm9wZW5haVwiXHJcbiAgfSxcclxuICBcInRleHQtZW1iZWRkaW5nLTMtc21hbGwtNTEyXCI6IHtcclxuICAgIFwibW9kZWxfbmFtZVwiOiBcInRleHQtZW1iZWRkaW5nLTMtc21hbGxcIixcclxuICAgIFwiYmF0Y2hfc2l6ZVwiOiA1MCxcclxuICAgIFwiZGltc1wiOiA1MTIsXHJcbiAgICBcIm1heF90b2tlbnNcIjogODE5MSxcclxuICAgIFwibmFtZVwiOiBcIk9wZW5BSSBUZXh0LTMgU21hbGwgLSA1MTJcIixcclxuICAgIFwiZGVzY3JpcHRpb25cIjogXCJBUEksIDgsMTkxIHRva2VucywgNTEyIGRpbVwiLFxyXG4gICAgXCJ0eXBlXCI6IFwib3BlbmFpXCJcclxuICB9LFxyXG4gIFwidGV4dC1lbWJlZGRpbmctMy1sYXJnZS0yNTZcIjoge1xyXG4gICAgXCJtb2RlbF9uYW1lXCI6IFwidGV4dC1lbWJlZGRpbmctMy1sYXJnZVwiLFxyXG4gICAgXCJiYXRjaF9zaXplXCI6IDUwLFxyXG4gICAgXCJkaW1zXCI6IDI1NixcclxuICAgIFwibWF4X3Rva2Vuc1wiOiA4MTkxLFxyXG4gICAgXCJuYW1lXCI6IFwiT3BlbkFJIFRleHQtMyBMYXJnZSAtIDI1NlwiLFxyXG4gICAgXCJkZXNjcmlwdGlvblwiOiBcIkFQSSwgOCwxOTEgdG9rZW5zLCAyNTYgZGltXCIsXHJcbiAgICBcInR5cGVcIjogXCJvcGVuYWlcIlxyXG4gIH0sXHJcbiAgXCJ0ZXh0LWVtYmVkZGluZy1hZGEtMDAyXCI6IHtcclxuICAgIFwibW9kZWxfbmFtZVwiOiBcInRleHQtZW1iZWRkaW5nLWFkYS0wMDJcIixcclxuICAgIFwiYmF0Y2hfc2l6ZVwiOiA1MCxcclxuICAgIFwiZGltc1wiOiAxNTM2LFxyXG4gICAgXCJtYXhfdG9rZW5zXCI6IDgxOTEsXHJcbiAgICBcIm5hbWVcIjogXCJPcGVuQUkgQWRhXCIsXHJcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiQVBJLCA4LDE5MSB0b2tlbnMsIDEsNTM2IGRpbVwiLFxyXG4gICAgXCJ0eXBlXCI6IFwib3BlbmFpXCJcclxuICB9XHJcbn0iLCAiY29uc3QgbW9kZWxzID0gcmVxdWlyZSgnLi9tb2RlbHMnKTtcclxuY2xhc3MgU21hcnRFbWJlZCB7XHJcbiAgY29uc3RydWN0b3IobW9kZWxfY29uZmlnX2tleSkge1xyXG4gICAgdGhpcy5tb2RlbF9jb25maWdfa2V5ID0gbW9kZWxfY29uZmlnX2tleTtcclxuICAgIHRoaXMuY29uZmlnID0gbW9kZWxzW3RoaXMubW9kZWxfY29uZmlnX2tleV07XHJcbiAgfVxyXG4gIHN0YXRpYyBhc3luYyBjcmVhdGUobW9kZWxfY29uZmlnX2tleSwgLi4uYXJncykge1xyXG4gICAgY29uc3QgYWRhcHRlciA9IG5ldyB0aGlzKG1vZGVsX2NvbmZpZ19rZXksIC4uLmFyZ3MpO1xyXG4gICAgYXdhaXQgYWRhcHRlci5pbml0KCk7XHJcbiAgICByZXR1cm4gYWRhcHRlcjtcclxuICB9XHJcbiAgYXN5bmMgaW5pdCgpIHsgfVxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpbnB1dFxyXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPG51bWJlcj59XHJcbiAgICovXHJcbiAgYXN5bmMgY291bnRfdG9rZW5zKGlucHV0KSB7IH1cclxuICAvKipcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gaW5wdXRcclxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxudW1iZXJbXT59XHJcbiAgICovXHJcbiAgYXN5bmMgZW1iZWQoaW5wdXQpIHsgfVxyXG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nW119IGlucHV0XHJcbiAgICogQHJldHVybnMge1Byb21pc2U8bnVtYmVyW11bXT59XHJcbiAgICovXHJcbiAgYXN5bmMgZW1iZWRfYmF0Y2goaW5wdXQpIHsgfVxyXG4gIGdldCBiYXRjaF9zaXplKCkgeyByZXR1cm4gdGhpcy5jb25maWcuYmF0Y2hfc2l6ZTsgfVxyXG4gIGdldCBkaW1zKCkgeyByZXR1cm4gdGhpcy5jb25maWcuZGltczsgfVxyXG4gIGdldCBtYXhfdG9rZW5zKCkgeyByZXR1cm4gdGhpcy5jb25maWcubWF4X3Rva2VuczsgfVxyXG4gIGdldCBtb2RlbF9uYW1lKCkgeyByZXR1cm4gdGhpcy5jb25maWcubW9kZWxfbmFtZTsgfVxyXG59XHJcblxyXG5leHBvcnRzLlNtYXJ0RW1iZWQgPSBTbWFydEVtYmVkOyIsICJjb25zdCB7IFNtYXJ0RW1iZWQgfSA9IHJlcXVpcmUoXCIuL1NtYXJ0RW1iZWRcIik7XHJcblxyXG5jbGFzcyBTbWFydEVtYmVkVHJhbnNmb3JtZXJzTm9kZUFkYXB0ZXIgZXh0ZW5kcyBTbWFydEVtYmVkIHtcclxuICAvLyBhc3luYyBpbml0KHRoaXMubW9kZWxfbmFtZSA9ICdYZW5vdmEvYmdlLXNtYWxsLWVuLXYxLjUnKSB7XHJcbiAgYXN5bmMgaW5pdCgpIHtcclxuICAgIGNvbnN0IHsgZW52LCBwaXBlbGluZSwgQXV0b1Rva2VuaXplciB9ID0gYXdhaXQgaW1wb3J0KCdAeGVub3ZhL3RyYW5zZm9ybWVycycpO1xyXG4gICAgZW52LmFsbG93TG9jYWxNb2RlbHMgPSBmYWxzZTtcclxuICAgIHRoaXMubW9kZWwgPSBhd2FpdCBwaXBlbGluZSgnZmVhdHVyZS1leHRyYWN0aW9uJywgdGhpcy5tb2RlbF9uYW1lLCB7IHF1YW50aXplZDogdHJ1ZSwgbWF4X2xlbmd0aDogdGhpcy5jb25maWcubWF4X3Rva2VucyB9KTtcclxuICAgIC8vIHRoaXMubW9kZWwgPSBhd2FpdCBwaXBlbGluZSgnZmVhdHVyZS1leHRyYWN0aW9uJywgdGhpcy5tb2RlbF9uYW1lLCB7IHF1YW50aXplZDogZmFsc2UgfSk7XHJcbiAgICB0aGlzLnRva2VuaXplciA9IGF3YWl0IEF1dG9Ub2tlbml6ZXIuZnJvbV9wcmV0cmFpbmVkKHRoaXMubW9kZWxfbmFtZSk7XHJcbiAgfVxyXG4gIGFzeW5jIGVtYmVkX2JhdGNoKGl0ZW1zKSB7XHJcbiAgICBpdGVtcyA9IGl0ZW1zLmZpbHRlcihpdGVtID0+IGl0ZW0uZW1iZWRfaW5wdXQ/Lmxlbmd0aCA+IDApOyAvLyByZW1vdmUgaXRlbXMgd2l0aCBlbXB0eSBlbWJlZF9pbnB1dCAoY2F1c2VzIC5zcGxpdCgpIGVycm9yKVxyXG4gICAgaWYoIWl0ZW1zPy5sZW5ndGgpIHJldHVybiBbXTtcclxuICAgIGNvbnN0IHRva2VucyA9IGF3YWl0IFByb21pc2UuYWxsKGl0ZW1zLm1hcChpdGVtID0+IHRoaXMuY291bnRfdG9rZW5zKGl0ZW0uZW1iZWRfaW5wdXQpKSk7XHJcbiAgICBjb25zdCBlbWJlZF9pbnB1dCA9IGF3YWl0IFByb21pc2UuYWxsKGl0ZW1zLm1hcChhc3luYyAoaXRlbSwgaSkgPT4ge1xyXG4gICAgICBpZiAodG9rZW5zW2ldIDwgdGhpcy5jb25maWcubWF4X3Rva2VucykgcmV0dXJuIGl0ZW0uZW1iZWRfaW5wdXQ7XHJcbiAgICAgIGxldCB0b2tlbl9jdCA9IHRva2Vuc1tpXTtcclxuICAgICAgbGV0IHRydW5jYXRlZF9pbnB1dCA9IGl0ZW0uZW1iZWRfaW5wdXQ7XHJcbiAgICAgIHdoaWxlICh0b2tlbl9jdCA+IHRoaXMuY29uZmlnLm1heF90b2tlbnMpIHtcclxuICAgICAgICBjb25zdCBwY3QgPSB0aGlzLmNvbmZpZy5tYXhfdG9rZW5zIC8gdG9rZW5fY3Q7IC8vIGdldCBwY3Qgb2YgaW5wdXQgdG8ga2VlcFxyXG4gICAgICAgIGNvbnN0IG1heF9jaGFycyA9IE1hdGguZmxvb3IodHJ1bmNhdGVkX2lucHV0Lmxlbmd0aCAqIHBjdCAqIDAuOTApOyAvLyBnZXQgbnVtYmVyIG9mIGNoYXJhY3RlcnMgdG8ga2VlcCAobWludXMgMTAlIGZvciBzYWZldHkpXHJcbiAgICAgICAgdHJ1bmNhdGVkX2lucHV0ID0gdHJ1bmNhdGVkX2lucHV0LnN1YnN0cmluZygwLCBtYXhfY2hhcnMpICsgXCIuLi5cIjtcclxuICAgICAgICB0b2tlbl9jdCA9IGF3YWl0IHRoaXMuY291bnRfdG9rZW5zKHRydW5jYXRlZF9pbnB1dCk7XHJcbiAgICAgIH1cclxuICAgICAgY29uc29sZS5sb2coXCJJbnB1dCB0b28gbG9uZy4gVHJ1bmNhdGluZyB0byBcIiwgdHJ1bmNhdGVkX2lucHV0Lmxlbmd0aCwgXCIgY2hhcmFjdGVycy5cIik7XHJcbiAgICAgIGNvbnNvbGUubG9nKFwiVG9rZW5zOiBcIiwgdG9rZW5zW2ldLCBcIiAtPiBcIiwgdG9rZW5fY3QpO1xyXG4gICAgICB0b2tlbnNbaV0gPSB0b2tlbl9jdDtcclxuICAgICAgcmV0dXJuIHRydW5jYXRlZF9pbnB1dDtcclxuICAgIH0pKTtcclxuXHJcbiAgICAvLyBjb25zb2xlLmxvZyhlbWJlZF9pbnB1dCk7XHJcbiAgICB0cnl7XHJcbiAgICAgIGNvbnN0IHJlc3AgPSBhd2FpdCB0aGlzLm1vZGVsKGVtYmVkX2lucHV0LCB7IHBvb2xpbmc6ICdtZWFuJywgbm9ybWFsaXplOiB0cnVlIH0pO1xyXG4gICAgICAvLyBjb25zb2xlLmxvZyhyZXNwKTtcclxuICAgICAgcmV0dXJuIGl0ZW1zLm1hcCgoaXRlbSwgaSkgPT4ge1xyXG4gICAgICAgIGl0ZW0udmVjID0gQXJyYXkuZnJvbShyZXNwW2ldLmRhdGEpO1xyXG4gICAgICAgIGl0ZW0udG9rZW5zID0gdG9rZW5zW2ldO1xyXG4gICAgICAgIHJldHVybiBpdGVtO1xyXG4gICAgICB9KTtcclxuICAgIH1jYXRjaChlcnIpe1xyXG4gICAgICBjb25zb2xlLmxvZyhlcnIpO1xyXG4gICAgICBjb25zb2xlLmxvZyhcIkVycm9yIGVtYmVkZGluZyBiYXRjaC4gVHJ5aW5nIG9uZSBhdCBhIHRpbWUuLi5cIik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYXdhaXQgUHJvbWlzZS5hbGwoaXRlbXMubWFwKGFzeW5jIGl0ZW0gPT4ge1xyXG4gICAgICBjb25zdCB7IHZlYywgdG9rZW5zLCBlcnJvciB9ID0gYXdhaXQgdGhpcy5lbWJlZChpdGVtLmVtYmVkX2lucHV0KTtcclxuICAgICAgaWYoZXJyb3Ipe1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiRXJyb3IgZW1iZWRkaW5nIGl0ZW06IFwiLCBpdGVtLmtleSk7XHJcbiAgICAgICAgY29uc29sZS5sb2coZXJyb3IpO1xyXG4gICAgICAgIGl0ZW0uZXJyb3IgPSBlcnJvcjtcclxuICAgICAgICByZXR1cm4gaXRlbTtcclxuICAgICAgfVxyXG4gICAgICBpZighdmVjKXtcclxuICAgICAgICBjb25zb2xlLmxvZyhcIkVycm9yIGVtYmVkZGluZyBpdGVtOiBcIiwgaXRlbS5rZXkpO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiVmVjOiBcIiwgdmVjKTtcclxuICAgICAgICBjb25zb2xlLmxvZyhcIkVycm9yOiBcIiwgZXJyb3IpO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiVG9rZW5zOiBcIiwgdG9rZW5zKTtcclxuICAgICAgICBjb25zb2xlLmxvZyhcIk5vIHZlYyByZXR1cm5lZFwiKTtcclxuICAgICAgICBpdGVtLmVycm9yID0gXCJObyB2ZWMgcmV0dXJuZWRcIjtcclxuICAgICAgICByZXR1cm4gaXRlbTtcclxuICAgICAgfVxyXG4gICAgICBpdGVtLnZlYyA9IHZlYy5tYXAodmFsID0+IE1hdGgucm91bmQodmFsICogMTAwMDAwMDAwKSAvIDEwMDAwMDAwMCk7IC8vIHJlZHVjZSBwcmVjaXNpb24gdG8gOCBkZWNpbWFsIHBsYWNlcyByZWY6IGh0dHBzOi8vd2ZoYnJpYW4uY29tL3ZlY3Rvci1kaW1lbnNpb24tcHJlY2lzaW9uLWVmZmVjdC1vbi1jb3NpbmUtc2ltaWxhcml0eS9cclxuICAgICAgaXRlbS50b2tlbnMgPSB0b2tlbnM7XHJcbiAgICAgIHJldHVybiBpdGVtO1xyXG4gICAgfSkpO1xyXG4gIH1cclxuICBhc3luYyBlbWJlZChpbnB1dCkge1xyXG4gICAgY29uc3Qgb3V0cHV0ID0geyBlbWJlZF9pbnB1dDogaW5wdXQgfTtcclxuICAgIGlmICghaW5wdXQpIHJldHVybiB7IC4uLm91dHB1dCwgZXJyb3I6IFwiTm8gaW5wdXQgdGV4dC5cIiB9O1xyXG4gICAgaWYgKCF0aGlzLm1vZGVsKSBhd2FpdCB0aGlzLmluaXQoKTtcclxuICAgIHRyeSB7XHJcbiAgICAgIG91dHB1dC50b2tlbnMgPSBhd2FpdCB0aGlzLmNvdW50X3Rva2VucyhpbnB1dCk7XHJcbiAgICAgIGlmIChvdXRwdXQudG9rZW5zIDwgMSkgcmV0dXJuIHsgLi4ub3V0cHV0LCBlcnJvcjogXCJJbnB1dCB0b28gc2hvcnQuXCIgfTtcclxuICAgICAgaWYgKG91dHB1dC50b2tlbnMgPCB0aGlzLmNvbmZpZy5tYXhfdG9rZW5zKSB7XHJcbiAgICAgICAgY29uc3QgZW1iZWRkaW5nID0gYXdhaXQgdGhpcy5tb2RlbChpbnB1dCwgeyBwb29saW5nOiAnbWVhbicsIG5vcm1hbGl6ZTogdHJ1ZSB9KTtcclxuICAgICAgICBvdXRwdXQudmVjID0gQXJyYXkuZnJvbShlbWJlZGRpbmcuZGF0YSkubWFwKHZhbCA9PiBNYXRoLnJvdW5kKHZhbCAqIDEwMDAwMDAwMCkgLyAxMDAwMDAwMDApOyAvLyByZWR1Y2UgcHJlY2lzaW9uIHRvIDggZGVjaW1hbCBwbGFjZXMgcmVmOiBodHRwczovL3dmaGJyaWFuLmNvbS92ZWN0b3ItZGltZW5zaW9uLXByZWNpc2lvbi1lZmZlY3Qtb24tY29zaW5lLXNpbWlsYXJpdHkvXHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY29uc3QgcGN0ID0gdGhpcy5jb25maWcubWF4X3Rva2VucyAvIG91dHB1dC50b2tlbnM7IC8vIGdldCBwY3Qgb2YgaW5wdXQgdG8ga2VlcFxyXG4gICAgICAgIGNvbnN0IG1heF9jaGFycyA9IE1hdGguZmxvb3IoaW5wdXQubGVuZ3RoICogcGN0ICogMC45NSk7IC8vIGdldCBudW1iZXIgb2YgY2hhcmFjdGVycyB0byBrZWVwIChtaW51cyA1JSBmb3Igc2FmZXR5KVxyXG4gICAgICAgIGlucHV0ID0gaW5wdXQuc3Vic3RyaW5nKDAsIG1heF9jaGFycykgKyBcIi4uLlwiO1xyXG4gICAgICAgIG91dHB1dC50cnVuY2F0ZWQgPSB0cnVlO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiSW5wdXQgdG9vIGxvbmcuIFRydW5jYXRpbmcgdG8gXCIsIGlucHV0Lmxlbmd0aCwgXCIgY2hhcmFjdGVycy5cIik7XHJcbiAgICAgICAgY29uc3QgeyB2ZWMsIHRva2VucyB9ID0gYXdhaXQgdGhpcy5lbWJlZChpbnB1dCk7XHJcbiAgICAgICAgb3V0cHV0LnZlYyA9IHZlYztcclxuICAgICAgICBvdXRwdXQudG9rZW5zID0gdG9rZW5zO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBvdXRwdXQ7XHJcbiAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgY29uc29sZS5sb2coZXJyKTtcclxuICAgICAgcmV0dXJuIHsgLi4ub3V0cHV0LCBlcnJvcjogZXJyLm1lc3NhZ2UgfTtcclxuICAgIH1cclxuICB9XHJcbiAgYXN5bmMgY291bnRfdG9rZW5zKHRleHQpIHtcclxuICAgIGlmICghdGhpcy50b2tlbml6ZXIpIGF3YWl0IHRoaXMuaW5pdCgpO1xyXG4gICAgY29uc3QgeyBpbnB1dF9pZHMgfSA9IGF3YWl0IHRoaXMudG9rZW5pemVyKHRleHQpO1xyXG4gICAgcmV0dXJuIGlucHV0X2lkcy5kYXRhLmxlbmd0aDsgLy8gUmV0dXJuIHRoZSBudW1iZXIgb2YgdG9rZW5zXHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnRzLlNtYXJ0RW1iZWRUcmFuc2Zvcm1lcnNOb2RlQWRhcHRlciA9IFNtYXJ0RW1iZWRUcmFuc2Zvcm1lcnNOb2RlQWRhcHRlcjtcclxuZXhwb3J0cy5TbWFydEVtYmVkTG9jYWxBZGFwdGVyID0gU21hcnRFbWJlZFRyYW5zZm9ybWVyc05vZGVBZGFwdGVyOyAvLyBhbGlhcyIsICJjb25zdCB7IFNtYXJ0RW1iZWRUcmFuc2Zvcm1lcnNOb2RlQWRhcHRlciB9ID0gcmVxdWlyZSgnLi9TbWFydEVtYmVkVHJhbnNmb3JtZXJzTm9kZUFkYXB0ZXInKTtcclxuY29uc3QgbW9kZWxzID0gcmVxdWlyZSgnLi9tb2RlbHMnKTtcclxuXHJcbi8vIENPTk5FQ1RPUiBGT1IgT0JTSURJQU5cclxuY2xhc3MgU21hcnRFbWJlZFRyYW5zZm9ybWVyc1dlYkNvbm5lY3RvciBleHRlbmRzIFNtYXJ0RW1iZWRUcmFuc2Zvcm1lcnNOb2RlQWRhcHRlciB7XHJcbiAgY29uc3RydWN0b3IobW9kZWxfY29uZmlnX2tleSwgd2luZG93KSB7XHJcbiAgICBzdXBlcihtb2RlbF9jb25maWdfa2V5KTtcclxuICAgIHRoaXMubW9kZWwgPSBudWxsO1xyXG4gICAgdGhpcy5ydW5uaW5nX2luaXQgPSBmYWxzZTtcclxuICAgIHRoaXMud2luZG93ID0gd2luZG93O1xyXG4gICAgLy8gc3RhdHNcclxuICAgIHRoaXMuZW1iZWRfY3QgPSAwO1xyXG4gICAgdGhpcy50aW1lc3RhbXAgPSBudWxsO1xyXG4gICAgdGhpcy50b2tlbnMgPSAwO1xyXG4gIH1cclxuICBhc3luYyBpbml0KCkge1xyXG4gICAgaWYgKHRoaXMubW9kZWwpIHJldHVybiBjb25zb2xlLmxvZyhcIlNtYXJ0IExvY2FsIE1vZGVsIGFscmVhZHkgbG9hZGVkXCIpO1xyXG4gICAgaWYgKHRoaXMucnVubmluZ19pbml0KSBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMzAwMCkpO1xyXG4gICAgaWYgKCF0aGlzLm1vZGVsICYmICF0aGlzLnJ1bm5pbmdfaW5pdCkgdGhpcy5ydW5uaW5nX2luaXQgPSB0cnVlO1xyXG4gICAgY29uc29sZS5sb2coXCJMb2FkaW5nIFNtYXJ0IExvY2FsIE1vZGVsXCIpO1xyXG4gICAgLy8gY29uc3QgeyBwaXBlbGluZSwgZW52LCBBdXRvVG9rZW5pemVyIH0gPSBhd2FpdCBpbXBvcnQoJ2h0dHBzOi8vY2RuLmpzZGVsaXZyLm5ldC9ucG0vQHhlbm92YS90cmFuc2Zvcm1lcnNAMi4xMy4wJyk7XHJcbiAgICBjb25zdCB7IHBpcGVsaW5lLCBlbnYsIEF1dG9Ub2tlbml6ZXIgfSA9IGF3YWl0IGltcG9ydCgnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9AeGVub3ZhL3RyYW5zZm9ybWVyc0BsYXRlc3QnKTtcclxuICAgIGVudi5hbGxvd0xvY2FsTW9kZWxzID0gZmFsc2U7XHJcbiAgICB0aGlzLm1vZGVsID0gYXdhaXQgcGlwZWxpbmUoJ2ZlYXR1cmUtZXh0cmFjdGlvbicsIHRoaXMubW9kZWxfbmFtZSwgeyBxdWFudGl6ZWQ6IHRydWUgfSk7XHJcbiAgICB0aGlzLnRva2VuaXplciA9IGF3YWl0IEF1dG9Ub2tlbml6ZXIuZnJvbV9wcmV0cmFpbmVkKHRoaXMubW9kZWxfbmFtZSk7XHJcbiAgICB0aGlzLnJ1bm5pbmdfaW5pdCA9IGZhbHNlO1xyXG4gICAgdGhpcy53aW5kb3cudG9rZW5pemVyID0gdGhpcy50b2tlbml6ZXI7XHJcbiAgICBjb25zb2xlLmxvZyhhd2FpdCB0aGlzLmVtYmVkKFwidGVzdFwiKSk7XHJcbiAgICB0aGlzLndpbmRvdy5wYXJlbnQucG9zdE1lc3NhZ2UoeyB0eXBlOiBcIm1vZGVsX2xvYWRlZFwiLCBkYXRhOiB0cnVlIH0sIFwiKlwiKTsgLy8gcG9zdCBtZXNzYWdlIHRvIHBhcmVudCB0aGF0IG1vZGVsIGlzIGxvYWRlZFxyXG4gICAgdGhpcy53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgdGhpcy5oYW5kbGVfaXBjLmJpbmQodGhpcyksIGZhbHNlKTtcclxuICB9XHJcbiAgYXN5bmMgaGFuZGxlX2lwYyhldmVudCkge1xyXG4gICAgaWYgKGV2ZW50LmRhdGEudHlwZSA9PSBcInNtYXJ0X2VtYmVkXCIpIHRoaXMuZW1iZWRfaGFuZGxlcihldmVudC5kYXRhKTtcclxuICAgIC8vIGlmIChldmVudC5kYXRhLnR5cGUgPT0gXCJzbWFydF9lbWJlZF9iYXRjaFwiKSB0aGlzLmVtYmVkX2JhdGNoX2hhbmRsZXIoZXZlbnQuZGF0YS5lbWJlZF9pbnB1dCk7XHJcbiAgICBpZiAoZXZlbnQuZGF0YS50eXBlID09IFwic21hcnRfZW1iZWRfdG9rZW5fY3RcIikgdGhpcy5jb3VudF90b2tlbnNfaGFuZGxlcihldmVudC5kYXRhLmVtYmVkX2lucHV0KTtcclxuICB9XHJcbiAgYXN5bmMgZW1iZWRfaGFuZGxlcihldmVudF9kYXRhKSB7XHJcbiAgICBjb25zdCB7IGVtYmVkX2lucHV0LCBoYW5kbGVyX2lkIH0gPSBldmVudF9kYXRhO1xyXG4gICAgLy8gY29uc29sZS5sb2coZW1iZWRfaW5wdXQpO1xyXG4gICAgaWYoIXRoaXMudGltZXN0YW1wKSB0aGlzLnRpbWVzdGFtcCA9IERhdGUubm93KCk7XHJcbiAgICBpZihBcnJheS5pc0FycmF5KGVtYmVkX2lucHV0KSkge1xyXG4gICAgICBjb25zdCByZXNwID0gYXdhaXQgdGhpcy5lbWJlZF9iYXRjaChlbWJlZF9pbnB1dCk7XHJcbiAgICAgIGNvbnN0IHNlbmRfZGF0YSA9IHtcclxuICAgICAgICB0eXBlOiBcInNtYXJ0X2VtYmVkX3Jlc3BcIixcclxuICAgICAgICBoYW5kbGVyX2lkLFxyXG4gICAgICAgIGRhdGE6IHJlc3AsXHJcbiAgICAgIH07XHJcbiAgICAgIHRoaXMud2luZG93LnBvc3RNZXNzYWdlKHNlbmRfZGF0YSwgXCIqXCIpO1xyXG4gICAgICB0aGlzLnRva2VucyArPSByZXNwLnJlZHVjZSgoYWNjLCBpdGVtKSA9PiBhY2MgKyBpdGVtLnRva2VucywgMCk7XHJcbiAgICAgIHRoaXMuZW1iZWRfY3QgKz0gcmVzcC5sZW5ndGg7XHJcbiAgICB9ZWxzZXtcclxuICAgICAgaWYgKCF0aGlzLnRpbWVzdGFtcCkgdGhpcy50aW1lc3RhbXAgPSBEYXRlLm5vdygpO1xyXG4gICAgICBjb25zdCBzZW5kX2RhdGEgPSBhd2FpdCB0aGlzLmVtYmVkKGVtYmVkX2lucHV0KTtcclxuICAgICAgc2VuZF9kYXRhLnR5cGUgPSBcInNtYXJ0X2VtYmVkX3Jlc3BcIjtcclxuICAgICAgaWYgKGhhbmRsZXJfaWQpIHNlbmRfZGF0YS5oYW5kbGVyX2lkID0gaGFuZGxlcl9pZDtcclxuICAgICAgdGhpcy53aW5kb3cucG9zdE1lc3NhZ2Uoc2VuZF9kYXRhLCBcIipcIik7XHJcbiAgICAgIHRoaXMudG9rZW5zICs9IHNlbmRfZGF0YS50b2tlbnM7XHJcbiAgICAgIHRoaXMuZW1iZWRfY3QrKztcclxuICAgIH1cclxuICAgIGlmIChEYXRlLm5vdygpIC0gdGhpcy50aW1lc3RhbXAgPiAxMDAwMCkge1xyXG4gICAgICBjb25zb2xlLmxvZyhgRW1iZWRkZWQ6ICR7dGhpcy5lbWJlZF9jdH0gaW5wdXRzICgke3RoaXMudG9rZW5zfSB0b2tlbnMsICR7KHRoaXMudG9rZW5zIC8gKChEYXRlLm5vdygpIC0gdGhpcy50aW1lc3RhbXApIC8gMTAwMCkpLnRvRml4ZWQoMCl9IHRva2Vucy9zZWMpYCk7XHJcbiAgICAgIHRoaXMudGltZXN0YW1wID0gbnVsbDtcclxuICAgICAgdGhpcy50b2tlbnMgPSAwO1xyXG4gICAgICB0aGlzLmVtYmVkX2N0ID0gMDtcclxuICAgIH1cclxuICB9XHJcbiAgYXN5bmMgY291bnRfdG9rZW5zX2hhbmRsZXIoaW5wdXQpIHtcclxuICAgIGNvbnN0IG91dHB1dCA9IGF3YWl0IHRoaXMuY291bnRfdG9rZW5zKGlucHV0KTtcclxuICAgIGNvbnN0IHNlbmRfZGF0YSA9IHtcclxuICAgICAgdHlwZTogXCJzbWFydF9lbWJlZF90b2tlbl9jdFwiLFxyXG4gICAgICB0ZXh0OiBcImNvdW50OlwiICsgaW5wdXQsXHJcbiAgICAgIGNvdW50OiBvdXRwdXRcclxuICAgIH07XHJcbiAgICB0aGlzLndpbmRvdy5wb3N0TWVzc2FnZShzZW5kX2RhdGEsIFwiKlwiKTtcclxuICB9XHJcbn1cclxuZXhwb3J0cy5TbWFydEVtYmVkVHJhbnNmb3JtZXJzV2ViQ29ubmVjdG9yID0gU21hcnRFbWJlZFRyYW5zZm9ybWVyc1dlYkNvbm5lY3RvcjsiLCAid2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBpbml0KTsgLy8gbGlzdGVuIGZvciBpbml0IG1lc3NhZ2VcclxuYXN5bmMgZnVuY3Rpb24gaW5pdChldmVudCkge1xyXG4gIGlmIChldmVudC5kYXRhLnR5cGUgPT09ICdpbml0Jykge1xyXG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBpbml0KTsgLy8gcmVtb3ZlIHRoaXMgZXZlbnQgbGlzdGVuZXJcclxuICAgIGNvbnN0IG1vZGVsX2NvbmZpZ19rZXkgPSBldmVudC5kYXRhLm1vZGVsX2NvbmZpZ19rZXk7XHJcbiAgICBjb25zdCB7IFNtYXJ0RW1iZWRUcmFuc2Zvcm1lcnNXZWJDb25uZWN0b3IgfSA9IGF3YWl0IGltcG9ydCgnLi9TbWFydEVtYmVkVHJhbnNmb3JtZXJzV2ViQ29ubmVjdG9yLmpzJyk7XHJcbiAgICBjb25zdCBtb2RlbCA9IGF3YWl0IFNtYXJ0RW1iZWRUcmFuc2Zvcm1lcnNXZWJDb25uZWN0b3IuY3JlYXRlKG1vZGVsX2NvbmZpZ19rZXksIHdpbmRvdyk7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\n"
}