{
  "script": "var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __commonJS = (cb, mod) => function __require() {\n  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\n\n// smart-embed/SmartEmbed.js\nvar require_SmartEmbed = __commonJS({\n  \"smart-embed/SmartEmbed.js\"(exports) {\n    var SmartEmbed = class {\n      static async create() {\n        const adapter = new this();\n        await adapter.init();\n        return adapter;\n      }\n      async init() {\n      }\n      /**\n       * @param {string} input\n       * @returns {Promise<number>}\n       */\n      async count_tokens(input) {\n      }\n      /**\n       * @param {string} input\n       * @returns {Promise<number[]>}\n       */\n      async embed(input) {\n      }\n      /**\n       * @param {string[]} input\n       * @returns {Promise<number[][]>}\n       */\n      async embed_batch(input) {\n      }\n    };\n    exports.SmartEmbed = SmartEmbed;\n  }\n});\n\n// smart-embed/SmartEmbedTransformersNodeAdapter.js\nvar require_SmartEmbedTransformersNodeAdapter = __commonJS({\n  \"smart-embed/SmartEmbedTransformersNodeAdapter.js\"(exports) {\n    var { SmartEmbed } = require_SmartEmbed();\n    var SmartEmbedTransformersNodeAdapter = class extends SmartEmbed {\n      async init(model_name = \"Xenova/bge-small-en-v1.5\") {\n        const { env, pipeline, AutoTokenizer } = await import(\"@xenova/transformers\");\n        env.allowLocalModels = false;\n        this.model = await pipeline(\"feature-extraction\", model_name, { quantized: true });\n        this.tokenizer = await AutoTokenizer.from_pretrained(model_name);\n      }\n      async embed_batch(items) {\n        const tokens = await Promise.all(items.map((item) => this.count_tokens(item.embed_input)));\n        const embed_input = items.map((item, i) => {\n          if (tokens[i] < 512)\n            return item.embed_input;\n          const pct = 512 / tokens[i];\n          const max_chars = Math.floor(item.embed_input.length * pct * 0.95);\n          return item.embed_input.substring(0, max_chars) + \"...\";\n        });\n        try {\n          const resp = await this.model(embed_input, { pooling: \"mean\", normalize: true });\n          return items.map((item, i) => {\n            item.vec = Array.from(resp[i].data);\n            item.tokens = item.embed_input.length;\n            return item;\n          });\n        } catch (err) {\n          console.log(err);\n          console.log(\"Error embedding batch. Trying one at a time...\");\n        }\n        return await Promise.all(items.map(async (item) => {\n          const { vec, tokens: tokens2, error } = await this.embed(item.embed_input);\n          if (error) {\n            console.log(\"Error embedding item: \", item.key);\n            console.log(error);\n            item.error = error;\n            return item;\n          }\n          item.vec = vec;\n          item.tokens = tokens2;\n          return item;\n        }));\n      }\n      async embed(input) {\n        const output = { text: input };\n        if (!input)\n          return { ...output, error: \"No input text.\" };\n        if (!this.model)\n          await this.init();\n        try {\n          output.tokens = await this.count_tokens(input);\n          if (output.tokens < 1)\n            return { ...output, error: \"Input too short.\" };\n          if (output.tokens < 512) {\n            const embedding = await this.model(input, { pooling: \"mean\", normalize: true });\n            output.vec = Array.from(embedding.data);\n          } else {\n            const pct = 512 / output.tokens;\n            const max_chars = Math.floor(input.length * pct * 0.95);\n            input = input.substring(0, max_chars) + \"...\";\n            output.truncated = true;\n            console.log(\"Input too long. Truncating to \", input.length, \" characters.\");\n            const { vec, tokens } = await this.embed(input);\n            output.vec = vec;\n            output.tokens = tokens;\n          }\n          return output;\n        } catch (err) {\n          console.log(err);\n          return { ...output, error: err.message };\n        }\n      }\n      async count_tokens(text) {\n        if (!this.tokenizer)\n          await this.init();\n        const { input_ids } = await this.tokenizer(text);\n        return input_ids.data.length;\n      }\n    };\n    exports.SmartEmbedTransformersNodeAdapter = SmartEmbedTransformersNodeAdapter;\n  }\n});\n\n// smart-embed/SmartEmbedTransformersWebConnector.js\nvar require_SmartEmbedTransformersWebConnector = __commonJS({\n  \"smart-embed/SmartEmbedTransformersWebConnector.js\"(exports) {\n    var { SmartEmbedTransformersNodeAdapter } = require_SmartEmbedTransformersNodeAdapter();\n    var SmartEmbedTransformersWebConnector = class extends SmartEmbedTransformersNodeAdapter {\n      constructor() {\n        super();\n        this.model = null;\n        this.running_init = false;\n        this.window = null;\n        this.embed_ct = 0;\n        this.timestamp = null;\n        this.tokens = 0;\n      }\n      async init() {\n        if (this.model)\n          return console.log(\"Smart Local Model already loaded\");\n        if (this.running_init)\n          await new Promise((resolve) => setTimeout(resolve, 3e3));\n        if (!this.model && !this.running_init)\n          this.running_init = true;\n        console.log(\"Loading Smart Local Model\");\n        const { pipeline, env, AutoTokenizer } = await import(\"https://cdn.jsdelivr.net/npm/@xenova/transformers@2.13.0\");\n        env.allowLocalModels = false;\n        this.model = await pipeline(\"feature-extraction\", this.model_name, { quantized: true });\n        this.tokenizer = await AutoTokenizer.from_pretrained(this.model_name);\n        this.running_init = false;\n        this.window.tokenizer = this.tokenizer;\n        console.log(await this.embed(\"test\"));\n        this.window.parent.postMessage({ type: \"model_loaded\", data: true }, \"*\");\n        this.window.addEventListener(\"message\", this.handle_ipc.bind(this), false);\n      }\n      async handle_ipc(event) {\n        if (event.data.type == \"smart_embed\")\n          this.embed_handler(event.data);\n        if (event.data.type == \"smart_embed_token_ct\")\n          this.count_tokens_handler(event.data.embed_input);\n      }\n      async embed_handler(event_data) {\n        const { embed_input, handler_id } = event_data;\n        if (!this.timestamp)\n          this.timestamp = Date.now();\n        if (Array.isArray(embed_input)) {\n          const resp = await this.embed_batch(embed_input);\n          const send_data = {\n            type: \"smart_embed_resp\",\n            handler_id,\n            data: resp\n          };\n          this.window.postMessage(send_data, \"*\");\n          this.tokens += resp.reduce((acc, item) => acc + item.tokens, 0);\n          this.embed_ct += resp.length;\n        } else {\n          if (!this.timestamp)\n            this.timestamp = Date.now();\n          const send_data = await this.embed(embed_input);\n          send_data.type = \"smart_embed\";\n          if (handler_id)\n            send_data.handler_id = handler_id;\n          this.window.postMessage(send_data, \"*\");\n          this.tokens += send_data.tokens;\n          this.embed_ct++;\n        }\n        if (Date.now() - this.timestamp > 1e4) {\n          console.log(`Embedded: ${this.embed_ct} inputs (${this.tokens} tokens, ${(this.tokens / ((Date.now() - this.timestamp) / 1e3)).toFixed(0)} tokens/sec)`);\n          this.timestamp = null;\n          this.tokens = 0;\n          this.embed_ct = 0;\n        }\n      }\n      async count_tokens_handler(input) {\n        const output = await this.count_tokens(input);\n        const send_data = {\n          type: \"smart_embed_token_ct\",\n          text: \"count:\" + input,\n          count: output\n        };\n        this.window.postMessage(send_data, \"*\");\n      }\n    };\n    exports.SmartEmbedTransformersWebConnector = SmartEmbedTransformersWebConnector;\n  }\n});\n\n// smart-embed/smart_embed_web.js\nwindow.addEventListener(\"message\", init);\nasync function init(event) {\n  if (event.data.type === \"init\") {\n    window.removeEventListener(\"message\", init);\n    const model_name = event.data.model_name;\n    const { SmartEmbedTransformersWebConnector } = await Promise.resolve().then(() => __toESM(require_SmartEmbedTransformersWebConnector()));\n    const model = new SmartEmbedTransformersWebConnector();\n    model.model_name = model_name;\n    model.window = window;\n    await model.init();\n    window.model = model;\n  }\n}\n//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsic21hcnQtZW1iZWQvU21hcnRFbWJlZC5qcyIsICJzbWFydC1lbWJlZC9TbWFydEVtYmVkVHJhbnNmb3JtZXJzTm9kZUFkYXB0ZXIuanMiLCAic21hcnQtZW1iZWQvU21hcnRFbWJlZFRyYW5zZm9ybWVyc1dlYkNvbm5lY3Rvci5qcyIsICJzbWFydC1lbWJlZC9zbWFydF9lbWJlZF93ZWIuanMiXSwKICAic291cmNlc0NvbnRlbnQiOiBbImNsYXNzIFNtYXJ0RW1iZWQge1xuICBzdGF0aWMgYXN5bmMgY3JlYXRlKCkge1xuICAgIGNvbnN0IGFkYXB0ZXIgPSBuZXcgdGhpcygpO1xuICAgIGF3YWl0IGFkYXB0ZXIuaW5pdCgpO1xuICAgIHJldHVybiBhZGFwdGVyO1xuICB9XG4gIGFzeW5jIGluaXQoKSB7IH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpbnB1dFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxudW1iZXI+fVxuICAgKi9cbiAgYXN5bmMgY291bnRfdG9rZW5zKGlucHV0KSB7IH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpbnB1dFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxudW1iZXJbXT59XG4gICAqL1xuICBhc3luYyBlbWJlZChpbnB1dCkgeyB9XG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBpbnB1dFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxudW1iZXJbXVtdPn1cbiAgICovXG4gIGFzeW5jIGVtYmVkX2JhdGNoKGlucHV0KSB7IH1cbn1cblxuZXhwb3J0cy5TbWFydEVtYmVkID0gU21hcnRFbWJlZDsiLCAiY29uc3QgeyBTbWFydEVtYmVkIH0gPSByZXF1aXJlKFwiLi9TbWFydEVtYmVkXCIpO1xuXG5jbGFzcyBTbWFydEVtYmVkVHJhbnNmb3JtZXJzTm9kZUFkYXB0ZXIgZXh0ZW5kcyBTbWFydEVtYmVkIHtcbiAgYXN5bmMgaW5pdChtb2RlbF9uYW1lID0gJ1hlbm92YS9iZ2Utc21hbGwtZW4tdjEuNScpIHtcbiAgICBjb25zdCB7IGVudiwgcGlwZWxpbmUsIEF1dG9Ub2tlbml6ZXIgfSA9IGF3YWl0IGltcG9ydCgnQHhlbm92YS90cmFuc2Zvcm1lcnMnKTtcbiAgICBlbnYuYWxsb3dMb2NhbE1vZGVscyA9IGZhbHNlO1xuICAgIHRoaXMubW9kZWwgPSBhd2FpdCBwaXBlbGluZSgnZmVhdHVyZS1leHRyYWN0aW9uJywgbW9kZWxfbmFtZSwgeyBxdWFudGl6ZWQ6IHRydWUgfSk7XG4gICAgdGhpcy50b2tlbml6ZXIgPSBhd2FpdCBBdXRvVG9rZW5pemVyLmZyb21fcHJldHJhaW5lZChtb2RlbF9uYW1lKTsgLy8gYmdlXG4gIH1cbiAgYXN5bmMgZW1iZWRfYmF0Y2goaXRlbXMpIHtcbiAgICBjb25zdCB0b2tlbnMgPSBhd2FpdCBQcm9taXNlLmFsbChpdGVtcy5tYXAoaXRlbSA9PiB0aGlzLmNvdW50X3Rva2VucyhpdGVtLmVtYmVkX2lucHV0KSkpO1xuICAgIGNvbnN0IGVtYmVkX2lucHV0ID0gaXRlbXMubWFwKChpdGVtLCBpKSA9PiB7XG4gICAgICBpZiAodG9rZW5zW2ldIDwgNTEyKSByZXR1cm4gaXRlbS5lbWJlZF9pbnB1dDtcbiAgICAgIGNvbnN0IHBjdCA9IDUxMiAvIHRva2Vuc1tpXTsgLy8gZ2V0IHBjdCBvZiBpbnB1dCB0byBrZWVwXG4gICAgICBjb25zdCBtYXhfY2hhcnMgPSBNYXRoLmZsb29yKGl0ZW0uZW1iZWRfaW5wdXQubGVuZ3RoICogcGN0ICogMC45NSk7IC8vIGdldCBudW1iZXIgb2YgY2hhcmFjdGVycyB0byBrZWVwIChtaW51cyA1JSBmb3Igc2FmZXR5KVxuICAgICAgcmV0dXJuIGl0ZW0uZW1iZWRfaW5wdXQuc3Vic3RyaW5nKDAsIG1heF9jaGFycykgKyBcIi4uLlwiO1xuICAgIH0pO1xuICAgIC8vIGNvbnNvbGUubG9nKGVtYmVkX2lucHV0KTtcbiAgICB0cnl7XG4gICAgICBjb25zdCByZXNwID0gYXdhaXQgdGhpcy5tb2RlbChlbWJlZF9pbnB1dCwgeyBwb29saW5nOiAnbWVhbicsIG5vcm1hbGl6ZTogdHJ1ZSB9KTtcbiAgICAgIC8vIGNvbnNvbGUubG9nKHJlc3ApO1xuICAgICAgcmV0dXJuIGl0ZW1zLm1hcCgoaXRlbSwgaSkgPT4ge1xuICAgICAgICBpdGVtLnZlYyA9IEFycmF5LmZyb20ocmVzcFtpXS5kYXRhKTtcbiAgICAgICAgaXRlbS50b2tlbnMgPSBpdGVtLmVtYmVkX2lucHV0Lmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICB9KTtcbiAgICB9Y2F0Y2goZXJyKXtcbiAgICAgIGNvbnNvbGUubG9nKGVycik7XG4gICAgICBjb25zb2xlLmxvZyhcIkVycm9yIGVtYmVkZGluZyBiYXRjaC4gVHJ5aW5nIG9uZSBhdCBhIHRpbWUuLi5cIik7XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCBQcm9taXNlLmFsbChpdGVtcy5tYXAoYXN5bmMgaXRlbSA9PiB7XG4gICAgICBjb25zdCB7IHZlYywgdG9rZW5zLCBlcnJvciB9ID0gYXdhaXQgdGhpcy5lbWJlZChpdGVtLmVtYmVkX2lucHV0KTtcbiAgICAgIGlmKGVycm9yKXtcbiAgICAgICAgY29uc29sZS5sb2coXCJFcnJvciBlbWJlZGRpbmcgaXRlbTogXCIsIGl0ZW0ua2V5KTtcbiAgICAgICAgY29uc29sZS5sb2coZXJyb3IpO1xuICAgICAgICBpdGVtLmVycm9yID0gZXJyb3I7XG4gICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgfVxuICAgICAgaXRlbS52ZWMgPSB2ZWM7XG4gICAgICBpdGVtLnRva2VucyA9IHRva2VucztcbiAgICAgIHJldHVybiBpdGVtO1xuICAgIH0pKTtcbiAgfVxuICBhc3luYyBlbWJlZChpbnB1dCkge1xuICAgIGNvbnN0IG91dHB1dCA9IHsgdGV4dDogaW5wdXQgfTtcbiAgICBpZiAoIWlucHV0KSByZXR1cm4geyAuLi5vdXRwdXQsIGVycm9yOiBcIk5vIGlucHV0IHRleHQuXCIgfTtcbiAgICBpZiAoIXRoaXMubW9kZWwpIGF3YWl0IHRoaXMuaW5pdCgpO1xuICAgIHRyeSB7XG4gICAgICBvdXRwdXQudG9rZW5zID0gYXdhaXQgdGhpcy5jb3VudF90b2tlbnMoaW5wdXQpO1xuICAgICAgaWYgKG91dHB1dC50b2tlbnMgPCAxKSByZXR1cm4geyAuLi5vdXRwdXQsIGVycm9yOiBcIklucHV0IHRvbyBzaG9ydC5cIiB9O1xuICAgICAgaWYgKG91dHB1dC50b2tlbnMgPCA1MTIpIHtcbiAgICAgICAgY29uc3QgZW1iZWRkaW5nID0gYXdhaXQgdGhpcy5tb2RlbChpbnB1dCwgeyBwb29saW5nOiAnbWVhbicsIG5vcm1hbGl6ZTogdHJ1ZSB9KTtcbiAgICAgICAgb3V0cHV0LnZlYyA9IEFycmF5LmZyb20oZW1iZWRkaW5nLmRhdGEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgcGN0ID0gNTEyIC8gb3V0cHV0LnRva2VuczsgLy8gZ2V0IHBjdCBvZiBpbnB1dCB0byBrZWVwXG4gICAgICAgIGNvbnN0IG1heF9jaGFycyA9IE1hdGguZmxvb3IoaW5wdXQubGVuZ3RoICogcGN0ICogMC45NSk7IC8vIGdldCBudW1iZXIgb2YgY2hhcmFjdGVycyB0byBrZWVwIChtaW51cyA1JSBmb3Igc2FmZXR5KVxuICAgICAgICBpbnB1dCA9IGlucHV0LnN1YnN0cmluZygwLCBtYXhfY2hhcnMpICsgXCIuLi5cIjtcbiAgICAgICAgb3V0cHV0LnRydW5jYXRlZCA9IHRydWU7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiSW5wdXQgdG9vIGxvbmcuIFRydW5jYXRpbmcgdG8gXCIsIGlucHV0Lmxlbmd0aCwgXCIgY2hhcmFjdGVycy5cIik7XG4gICAgICAgIGNvbnN0IHsgdmVjLCB0b2tlbnMgfSA9IGF3YWl0IHRoaXMuZW1iZWQoaW5wdXQpO1xuICAgICAgICBvdXRwdXQudmVjID0gdmVjO1xuICAgICAgICBvdXRwdXQudG9rZW5zID0gdG9rZW5zO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUubG9nKGVycik7XG4gICAgICByZXR1cm4geyAuLi5vdXRwdXQsIGVycm9yOiBlcnIubWVzc2FnZSB9O1xuICAgIH1cbiAgfVxuICBhc3luYyBjb3VudF90b2tlbnModGV4dCkge1xuICAgIGlmICghdGhpcy50b2tlbml6ZXIpIGF3YWl0IHRoaXMuaW5pdCgpO1xuICAgIGNvbnN0IHsgaW5wdXRfaWRzIH0gPSBhd2FpdCB0aGlzLnRva2VuaXplcih0ZXh0KTtcbiAgICByZXR1cm4gaW5wdXRfaWRzLmRhdGEubGVuZ3RoOyAvLyBSZXR1cm4gdGhlIG51bWJlciBvZiB0b2tlbnNcbiAgfVxufVxuXG5leHBvcnRzLlNtYXJ0RW1iZWRUcmFuc2Zvcm1lcnNOb2RlQWRhcHRlciA9IFNtYXJ0RW1iZWRUcmFuc2Zvcm1lcnNOb2RlQWRhcHRlcjsiLCAiY29uc3QgeyBTbWFydEVtYmVkVHJhbnNmb3JtZXJzTm9kZUFkYXB0ZXIgfSA9IHJlcXVpcmUoJy4vU21hcnRFbWJlZFRyYW5zZm9ybWVyc05vZGVBZGFwdGVyJyk7XG5cbi8vIENPTk5FQ1RPUiBGT1IgT0JTSURJQU5cbmNsYXNzIFNtYXJ0RW1iZWRUcmFuc2Zvcm1lcnNXZWJDb25uZWN0b3IgZXh0ZW5kcyBTbWFydEVtYmVkVHJhbnNmb3JtZXJzTm9kZUFkYXB0ZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMubW9kZWwgPSBudWxsO1xuICAgIHRoaXMucnVubmluZ19pbml0ID0gZmFsc2U7XG4gICAgdGhpcy53aW5kb3cgPSBudWxsO1xuICAgIC8vIHN0YXRzXG4gICAgdGhpcy5lbWJlZF9jdCA9IDA7XG4gICAgdGhpcy50aW1lc3RhbXAgPSBudWxsO1xuICAgIHRoaXMudG9rZW5zID0gMDtcbiAgfVxuICBhc3luYyBpbml0KCkge1xuICAgIGlmICh0aGlzLm1vZGVsKSByZXR1cm4gY29uc29sZS5sb2coXCJTbWFydCBMb2NhbCBNb2RlbCBhbHJlYWR5IGxvYWRlZFwiKTtcbiAgICBpZiAodGhpcy5ydW5uaW5nX2luaXQpIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAzMDAwKSk7XG4gICAgaWYgKCF0aGlzLm1vZGVsICYmICF0aGlzLnJ1bm5pbmdfaW5pdCkgdGhpcy5ydW5uaW5nX2luaXQgPSB0cnVlO1xuICAgIGNvbnNvbGUubG9nKFwiTG9hZGluZyBTbWFydCBMb2NhbCBNb2RlbFwiKTtcbiAgICBjb25zdCB7IHBpcGVsaW5lLCBlbnYsIEF1dG9Ub2tlbml6ZXIgfSA9IGF3YWl0IGltcG9ydCgnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9AeGVub3ZhL3RyYW5zZm9ybWVyc0AyLjEzLjAnKTtcbiAgICBlbnYuYWxsb3dMb2NhbE1vZGVscyA9IGZhbHNlO1xuICAgIHRoaXMubW9kZWwgPSBhd2FpdCBwaXBlbGluZSgnZmVhdHVyZS1leHRyYWN0aW9uJywgdGhpcy5tb2RlbF9uYW1lLCB7IHF1YW50aXplZDogdHJ1ZSB9KTtcbiAgICB0aGlzLnRva2VuaXplciA9IGF3YWl0IEF1dG9Ub2tlbml6ZXIuZnJvbV9wcmV0cmFpbmVkKHRoaXMubW9kZWxfbmFtZSk7XG4gICAgdGhpcy5ydW5uaW5nX2luaXQgPSBmYWxzZTtcbiAgICB0aGlzLndpbmRvdy50b2tlbml6ZXIgPSB0aGlzLnRva2VuaXplcjtcbiAgICBjb25zb2xlLmxvZyhhd2FpdCB0aGlzLmVtYmVkKFwidGVzdFwiKSk7XG4gICAgdGhpcy53aW5kb3cucGFyZW50LnBvc3RNZXNzYWdlKHsgdHlwZTogXCJtb2RlbF9sb2FkZWRcIiwgZGF0YTogdHJ1ZSB9LCBcIipcIik7IC8vIHBvc3QgbWVzc2FnZSB0byBwYXJlbnQgdGhhdCBtb2RlbCBpcyBsb2FkZWRcbiAgICB0aGlzLndpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCB0aGlzLmhhbmRsZV9pcGMuYmluZCh0aGlzKSwgZmFsc2UpO1xuICB9XG4gIGFzeW5jIGhhbmRsZV9pcGMoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQuZGF0YS50eXBlID09IFwic21hcnRfZW1iZWRcIikgdGhpcy5lbWJlZF9oYW5kbGVyKGV2ZW50LmRhdGEpO1xuICAgIC8vIGlmIChldmVudC5kYXRhLnR5cGUgPT0gXCJzbWFydF9lbWJlZF9iYXRjaFwiKSB0aGlzLmVtYmVkX2JhdGNoX2hhbmRsZXIoZXZlbnQuZGF0YS5lbWJlZF9pbnB1dCk7XG4gICAgaWYgKGV2ZW50LmRhdGEudHlwZSA9PSBcInNtYXJ0X2VtYmVkX3Rva2VuX2N0XCIpIHRoaXMuY291bnRfdG9rZW5zX2hhbmRsZXIoZXZlbnQuZGF0YS5lbWJlZF9pbnB1dCk7XG4gIH1cbiAgYXN5bmMgZW1iZWRfaGFuZGxlcihldmVudF9kYXRhKSB7XG4gICAgY29uc3QgeyBlbWJlZF9pbnB1dCwgaGFuZGxlcl9pZCB9ID0gZXZlbnRfZGF0YTtcbiAgICAvLyBjb25zb2xlLmxvZyhlbWJlZF9pbnB1dCk7XG4gICAgaWYoIXRoaXMudGltZXN0YW1wKSB0aGlzLnRpbWVzdGFtcCA9IERhdGUubm93KCk7XG4gICAgaWYoQXJyYXkuaXNBcnJheShlbWJlZF9pbnB1dCkpIHtcbiAgICAgIGNvbnN0IHJlc3AgPSBhd2FpdCB0aGlzLmVtYmVkX2JhdGNoKGVtYmVkX2lucHV0KTtcbiAgICAgIGNvbnN0IHNlbmRfZGF0YSA9IHtcbiAgICAgICAgdHlwZTogXCJzbWFydF9lbWJlZF9yZXNwXCIsXG4gICAgICAgIGhhbmRsZXJfaWQsXG4gICAgICAgIGRhdGE6IHJlc3AsXG4gICAgICB9O1xuICAgICAgdGhpcy53aW5kb3cucG9zdE1lc3NhZ2Uoc2VuZF9kYXRhLCBcIipcIik7XG4gICAgICB0aGlzLnRva2VucyArPSByZXNwLnJlZHVjZSgoYWNjLCBpdGVtKSA9PiBhY2MgKyBpdGVtLnRva2VucywgMCk7XG4gICAgICB0aGlzLmVtYmVkX2N0ICs9IHJlc3AubGVuZ3RoO1xuICAgIH1lbHNle1xuICAgICAgaWYgKCF0aGlzLnRpbWVzdGFtcCkgdGhpcy50aW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuICAgICAgY29uc3Qgc2VuZF9kYXRhID0gYXdhaXQgdGhpcy5lbWJlZChlbWJlZF9pbnB1dCk7XG4gICAgICBzZW5kX2RhdGEudHlwZSA9IFwic21hcnRfZW1iZWRcIjtcbiAgICAgIGlmIChoYW5kbGVyX2lkKSBzZW5kX2RhdGEuaGFuZGxlcl9pZCA9IGhhbmRsZXJfaWQ7XG4gICAgICB0aGlzLndpbmRvdy5wb3N0TWVzc2FnZShzZW5kX2RhdGEsIFwiKlwiKTtcbiAgICAgIHRoaXMudG9rZW5zICs9IHNlbmRfZGF0YS50b2tlbnM7XG4gICAgICB0aGlzLmVtYmVkX2N0Kys7XG4gICAgfVxuICAgIGlmIChEYXRlLm5vdygpIC0gdGhpcy50aW1lc3RhbXAgPiAxMDAwMCkge1xuICAgICAgY29uc29sZS5sb2coYEVtYmVkZGVkOiAke3RoaXMuZW1iZWRfY3R9IGlucHV0cyAoJHt0aGlzLnRva2Vuc30gdG9rZW5zLCAkeyh0aGlzLnRva2VucyAvICgoRGF0ZS5ub3coKSAtIHRoaXMudGltZXN0YW1wKSAvIDEwMDApKS50b0ZpeGVkKDApfSB0b2tlbnMvc2VjKWApO1xuICAgICAgdGhpcy50aW1lc3RhbXAgPSBudWxsO1xuICAgICAgdGhpcy50b2tlbnMgPSAwO1xuICAgICAgdGhpcy5lbWJlZF9jdCA9IDA7XG4gICAgfVxuICB9XG4gIGFzeW5jIGNvdW50X3Rva2Vuc19oYW5kbGVyKGlucHV0KSB7XG4gICAgY29uc3Qgb3V0cHV0ID0gYXdhaXQgdGhpcy5jb3VudF90b2tlbnMoaW5wdXQpO1xuICAgIGNvbnN0IHNlbmRfZGF0YSA9IHtcbiAgICAgIHR5cGU6IFwic21hcnRfZW1iZWRfdG9rZW5fY3RcIixcbiAgICAgIHRleHQ6IFwiY291bnQ6XCIgKyBpbnB1dCxcbiAgICAgIGNvdW50OiBvdXRwdXRcbiAgICB9O1xuICAgIHRoaXMud2luZG93LnBvc3RNZXNzYWdlKHNlbmRfZGF0YSwgXCIqXCIpO1xuICB9XG59XG5leHBvcnRzLlNtYXJ0RW1iZWRUcmFuc2Zvcm1lcnNXZWJDb25uZWN0b3IgPSBTbWFydEVtYmVkVHJhbnNmb3JtZXJzV2ViQ29ubmVjdG9yOyIsICJ3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGluaXQpOyAvLyBsaXN0ZW4gZm9yIGluaXQgbWVzc2FnZVxuYXN5bmMgZnVuY3Rpb24gaW5pdChldmVudCkge1xuICBpZiAoZXZlbnQuZGF0YS50eXBlID09PSAnaW5pdCcpIHtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGluaXQpOyAvLyByZW1vdmUgdGhpcyBldmVudCBsaXN0ZW5lclxuICAgIGNvbnN0IG1vZGVsX25hbWUgPSBldmVudC5kYXRhLm1vZGVsX25hbWU7XG4gICAgY29uc3QgeyBTbWFydEVtYmVkVHJhbnNmb3JtZXJzV2ViQ29ubmVjdG9yIH0gPSBhd2FpdCBpbXBvcnQoJy4vU21hcnRFbWJlZFRyYW5zZm9ybWVyc1dlYkNvbm5lY3Rvci5qcycpO1xuICAgIGNvbnN0IG1vZGVsID0gbmV3IFNtYXJ0RW1iZWRUcmFuc2Zvcm1lcnNXZWJDb25uZWN0b3IoKTtcbiAgICBtb2RlbC5tb2RlbF9uYW1lID0gbW9kZWxfbmFtZTtcbiAgICBtb2RlbC53aW5kb3cgPSB3aW5kb3c7XG4gICAgYXdhaXQgbW9kZWwuaW5pdCgpO1xuICAgIHdpbmRvdy5tb2RlbCA9IG1vZGVsO1xuICB9XG59Il0sCiAgIm1hcHBpbmdzIjogIjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFBQTtBQUFBLFFBQU0sYUFBTixNQUFpQjtBQUFBLE1BQ2YsYUFBYSxTQUFTO0FBQ3BCLGNBQU0sVUFBVSxJQUFJLEtBQUs7QUFDekIsY0FBTSxRQUFRLEtBQUs7QUFDbkIsZUFBTztBQUFBLE1BQ1Q7QUFBQSxNQUNBLE1BQU0sT0FBTztBQUFBLE1BQUU7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BS2YsTUFBTSxhQUFhLE9BQU87QUFBQSxNQUFFO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQUs1QixNQUFNLE1BQU0sT0FBTztBQUFBLE1BQUU7QUFBQTtBQUFBO0FBQUE7QUFB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\n"
}